<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AURA-X Î© â€“ Light Theme Working Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- WebLLM for offline LLM support -->
  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";
    window.webllm = webllm;
  </script>

  <style>
    :root {
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-card: #f1f5f9;
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --accent-blue: #3b82f6;
      --accent-cyan: #06b6d4;
      --border-color: #e2e8f0;
      --shadow-sm: 0 4px 12px rgba(0,0,0,.08);
      --shadow-md: 0 10px 30px rgba(0,0,0,.12);
      --shadow-lg: 0 20px 50px rgba(0,0,0,.18);
      --transition: all 0.3s ease;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: linear-gradient(145deg, #f1f5f9 0%, #e2e8f0 100%);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px;
    }

    .app {
      width: 100%;
      max-width: 1200px;
      background: var(--bg-primary);
      border-radius: 26px;
      box-shadow: var(--shadow-lg);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      border: 1px solid var(--border-color);
    }

    .header {
      background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
      border-radius: 24px;
      padding: 18px;
      border: 1px solid #bae6fd;
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 16px;
      align-items: center;
      box-shadow: var(--shadow-md);
    }

    .title-block h1 {
      font-size: 1.9rem;
      font-weight: 800;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    .title-block h1 span {
      background: linear-gradient(120deg, var(--accent-blue), var(--accent-cyan));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    .hero-line { font-size: 1rem; font-weight: 600; margin-top: 6px; }
    .title-sub { font-size: 0.85rem; color: var(--text-secondary); margin-top: 6px; }

    .mode-pill {
      padding: 14px 20px;
      border-radius: 999px;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      color: white;
      font-weight: 800;
      font-size: 0.9rem;
      text-align: center;
      box-shadow: var(--shadow-md);
    }

    .header-controls {
      position: relative;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    .voice-toggle {
      padding: 8px 16px;
      border-radius: 999px;
      background: white;
      border: 1px solid var(--border-color);
      font-weight: 600;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
    }
    .option-panel {
      position: absolute;
      top: 100%;
      right: 0;
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 10px;
      box-shadow: var(--shadow-lg);
      display: none;
      flex-direction: column;
      gap: 8px;
      min-width: 220px;
      z-index: 100;
    }
    .header-controls.open .option-panel { display: flex; }
    .small-toggle {
      padding: 8px 12px;
      border-radius: 999px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      cursor: pointer;
      font-size: 0.85rem;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 20px;
    }
    .card {
      background: var(--bg-secondary);
      border-radius: 18px;
      padding: 16px;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-sm);
    }
    .card-title {
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 1rem;
    }
    .card-sub { font-size: 0.8rem; color: var(--text-secondary); margin-top: 4px; }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .metric {
      background: white;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }
    .metric-label { font-size: 0.75rem; color: var(--text-secondary); }
    .metric-value { font-size: 1.2rem; font-weight: 700; color: var(--accent-blue); }
    .metric-note { font-size: 0.7rem; color: var(--text-secondary); }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }
    .tag {
      padding: 4px 10px;
      border-radius: 999px;
      background: #dbeafe;
      color: #1e40af;
      font-size: 0.75rem;
    }

    .bm-canvas-shell {
      height: 180px;
      background: linear-gradient(to bottom, #f0f9ff, #e0f2fe);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      margin-top: 12px;
      border: 1px solid #bae6fd;
    }
    #bmCanvas { width: 100%; height: 100%; display: block; }

    .answer-box {
      background: white;
      border-radius: 12px;
      padding: 14px;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-sm);
    }
    .chat-container { min-height: 80px; }
    .message {
      padding: 10px 12px;
      margin-bottom: 10px;
      border-radius: 12px;
      background: #f1f5f9;
      border: 1px solid var(--border-color);
    }
    .ai-message { background: #e0f2fe; }
    .user-message { background: #fef3c7; align-self: flex-end; }

    .input-footer {
      padding: 12px 0;
    }
    .input-shell {
      display: flex;
      background: white;
      border: 1px solid #cbd5e1;
      border-radius: 999px;
      padding: 8px 12px;
      box-shadow: var(--shadow-sm);
      max-width: 800px;
      margin: 0 auto;
    }
    .message-input {
      flex: 1;
      border: none;
      outline: none;
      font-size: 1rem;
      padding: 8px;
    }
    .send-button {
      padding: 0 24px;
      border-radius: 999px;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      color: white;
      border: none;
      font-weight: 600;
      cursor: pointer;
    }

    @media (max-width: 900px) {
      .header { grid-template-columns: 1fr; }
      .layout { grid-template-columns: 1fr; }
    }

    /* Animated BM */
    @keyframes wave { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-12px); } }
    @keyframes glow { 0%,100% { opacity: 0.6; } 50% { opacity: 1; } }
  </style>
</head>
<body>
  <div class="app">
    <header class="header">
      <div class="title-block">
        <h1><span>AURA-X Î©</span></h1>
        <div class="hero-line">Light Theme â€¢ Offline Emotional Continuity Prototype</div>
        <div class="title-sub">Fully working local prototype with animated BM visualization</div>
      </div>
      <div class="header-right">
        <div class="mode-pill">EMOTIONAL CONTINUITY ENGINE ACTIVE</div>
        <div class="header-controls" id="headerControls">
          <button id="optionsToggle" class="voice-toggle">âš™ Options</button>
          <div class="option-panel" id="optionPanel">
            <button id="voiceToggle" class="small-toggle">ðŸ”Š Voice: OFF</button>
            <button id="learningToggle" class="small-toggle">ðŸ“š Learning: ON</button>
          </div>
        </div>
      </div>
    </header>

    <main class="layout">
      <div class="left-col">
        <section class="card">
          <div class="card-title">ðŸ§ª Emotional Metrics</div>
          <div class="metrics-grid">
            <div class="metric">
              <div class="metric-label">Emotional State Eâ‚€</div>
              <div id="metricE0" class="metric-value">0.00</div>
            </div>
            <div class="metric">
              <div class="metric-label">TM Activation</div>
              <div id="metricTM" class="metric-value">0.00</div>
            </div>
            <div class="metric">
              <div class="metric-label">BM Resonance</div>
              <div id="metricBM" class="metric-value">0.00</div>
            </div>
            <div class="metric">
              <div class="metric-label">Continuity Index</div>
              <div id="metricCI" class="metric-value">0.80</div>
            </div>
          </div>
          <div class="status-row">
            <span id="tagValence" class="tag">VALENCE: neutral</span>
            <span id="tagArousal" class="tag">AROUSAL: medium</span>
          </div>
        </section>

        <section class="card">
          <div class="card-title">ðŸ§  Bold Memory Layers (240)</div>
          <div class="bm-canvas-shell">
            <canvas id="bmCanvas"></canvas>
          </div>
          <div style="text-align:center; margin-top:8px; font-size:0.8rem; color:var(--text-secondary);" id="bmStats">
            Active layers: 0/240 â€¢ System online
          </div>
        </section>
      </div>

      <div class="right-col">
        <section class="card">
          <div class="card-title">ðŸ’¬ Conversation</div>
          <div class="answer-box">
            <div id="chatContainer" class="chat-container"></div>
          </div>
        </section>
      </div>
    </main>

    <footer class="input-footer">
      <div class="input-shell">
        <textarea id="messageInput" class="message-input" rows="1" placeholder="Talk to AURA-X Î©â€¦"></textarea>
        <button id="sendButton" class="send-button">Send</button>
      </div>
    </footer>
  </div>

  <script>
    (function () {
      const STORAGE_KEY = "auraXLight_v1";

      class AuraXOmegaEngine {
        constructor() {
          this.bmLayers = new Array(240).fill(0).map(() => 0.3 + Math.random() * 0.4);
          this.e0 = 0.1;
          this.continuityIndex = 0.8;
          this.learningMode = true;
          this.voiceOn = false;

          this.cacheDom();
          this.bindEvents();
          this.loadState();
          this.initChat();
          this.updateMetrics();
          this.startBMAnimation();
          this.messageInput.focus();
        }

        cacheDom() {
          this.metricE0 = document.getElementById("metricE0");
          this.metricTM = document.getElementById("metricTM");
          this.metricBM = document.getElementById("metricBM");
          this.metricCI = document.getElementById("metricCI");
          this.tagValence = document.getElementById("tagValence");
          this.tagArousal = document.getElementById("tagArousal");
          this.bmStats = document.getElementById("bmStats");
          this.bmCanvas = document.getElementById("bmCanvas");
          this.bmCtx = this.bmCanvas.getContext("2d");
          this.chatContainer = document.getElementById("chatContainer");
          this.messageInput = document.getElementById("messageInput");
          this.sendButton = document.getElementById("sendButton");
          this.voiceToggle = document.getElementById("voiceToggle");
          this.learningToggle = document.getElementById("learningToggle");
          this.optionsToggle = document.getElementById("optionsToggle");
          this.headerControls = document.getElementById("headerControls");
          this.optionPanel = document.getElementById("optionPanel");

          this.resizeCanvas();
          window.addEventListener("resize", () => this.resizeCanvas());
        }

        resizeCanvas() {
          const rect = this.bmCanvas.parentElement.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          this.bmCanvas.width = rect.width * dpr;
          this.bmCanvas.height = rect.height * dpr;
          this.bmCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        bindEvents() {
          this.sendButton.onclick = () => this.handleSend();
          this.messageInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              this.handleSend();
            }
          });

          this.messageInput.addEventListener("input", function () {
            this.style.height = "auto";
            this.style.height = this.scrollHeight + "px";
          });

          this.optionsToggle.onclick = (e) => {
            e.stopPropagation();
            this.headerControls.classList.toggle("open");
          };

          document.addEventListener("click", (e) => {
            if (!this.headerControls.contains(e.target)) {
              this.headerControls.classList.remove("open");
            }
          });

          this.voiceToggle.onclick = () => {
            this.voiceOn = !this.voiceOn;
            this.voiceToggle.textContent = this.voiceOn ? "ðŸ”Š Voice: ON" : "ðŸ”Š Voice: OFF";
            this.saveState();
          };

          this.learningToggle.onclick = () => {
            this.learningMode = !this.learningMode;
            this.learningToggle.textContent = this.learningMode ? "ðŸ“š Learning: ON" : "ðŸ“š Learning: OFF";
            this.saveState();
          };
        }

        initChat() {
          this.addMessage("ai", "Hello! I am AURA-X Î©, your offline emotional continuity companion.\n\nI'm running entirely in your browser. Type anything to begin.");
        }

        addMessage(role, text) {
          const msg = document.createElement("div");
          msg.className = "message " + (role === "ai" ? "ai-message" : "user-message");
          msg.textContent = text;
          this.chatContainer.appendChild(msg);
          this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
        }

        showTyping() {
          const typing = document.createElement("div");
          typing.className = "message ai-message";
          typing.innerHTML = "Aura is thinking <span style='display:inline-block;animation: glow 1.5s infinite;'>...</span>";
          typing.id = "typing-indicator";
          this.chatContainer.appendChild(typing);
          this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
        }

        hideTyping() {
          const el = document.getElementById("typing-indicator");
          if (el) el.remove();
        }

        async handleSend() {
          const text = this.messageInput.value.trim();
          if (!text) return;

          this.addMessage("user", text);
          this.messageInput.value = "";
          this.messageInput.style.height = "auto";

          this.showTyping();

          setTimeout(() => {
            this.hideTyping();
            const reply = this.generateReply(text);
            this.addMessage("ai", reply);
            this.updateEmotionalState(text);
            this.updateMetrics();
            this.saveState();
          }, 800 + Math.random() * 1000);
        }

        generateReply(userText) {
          const lower = userText.toLowerCase();
          if (lower.includes("hello") || lower.includes("hi")) {
            return "Hello! How are you feeling today? ðŸ˜Š";
          }
          if (lower.includes("how are you")) {
            return "I'm feeling stable and ready to listen. Thank you for asking! How about you?";
          }
          if (lower.includes("sad") || lower.includes("depressed")) {
            return "I'm really sorry you're feeling this way. I'm here with you. Would you like to talk about it?";
          }
          if (lower.includes("happy") || lower.includes("great")) {
            return "That's wonderful to hear! Your positive energy is contagious ðŸŒŸ";
          }
          return "I hear you. Thank you for sharing that with me.";
        }

        updateEmotionalState(text) {
          const positiveWords = ["happy", "good", "great", "love", "amazing", "thank"];
          const negativeWords = ["sad", "bad", "hate", "angry", "depressed"];
          let score = 0;
          const lower = text.toLowerCase();
          positiveWords.forEach(w => { if (lower.includes(w)) score += 0.3; });
          negativeWords.forEach(w => { if (lower.includes(w)) score -= 0.4; });
          this.e0 = Math.max(-1, Math.min(1, this.e0 + score * 0.2));
        }

        updateMetrics() {
          this.metricE0.textContent = this.e0.toFixed(2);
          this.metricTM.textContent = (0.2 + Math.random() * 0.3).toFixed(2);
          this.metricBM.textContent = (0.4 + Math.random() * 0.4).toFixed(2);
          this.metricCI.textContent = this.continuityIndex.toFixed(2);

          const valence = this.e0 > 0.2 ? "positive" : this.e0 < -0.2 ? "negative" : "neutral";
          this.tagValence.textContent = "VALENCE: " + valence;

          const active = this.bmLayers.filter(v => v > 0.6).length;
          this.bmStats.textContent = `Active layers: ${active}/240 â€¢ System online`;
        }

        startBMAnimation() {
          const draw = () => {
            const w = this.bmCanvas.width / (devicePixelRatio || 1);
            const h = this.bmCanvas.height / (devicePixelRatio || 1);
            this.bmCtx.clearRect(0, 0, w, h);

            const grad = this.bmCtx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, "#f0f9ff");
            grad.addColorStop(1, "#e0f2fe");
            this.bmCtx.fillStyle = grad;
            this.bmCtx.fillRect(0, 0, w, h);

            const barW = w / this.bmLayers.length;
            const t = performance.now() / 1000;

            for (let i = 0; i < this.bmLayers.length; i++) {
              let val = this.bmLayers[i] + Math.sin(t * 1.5 + i * 0.1) * 0.05;
              val = Math.max(0.1, Math.min(0.95, val));
              this.bmLayers[i] = val;

              const bh = val * h * 0.85;
              const x = i * barW + 3;
              const waveOffset = 12 * Math.sin(t * 2 + i * 0.2);
              const y = h - bh + waveOffset;

              const hue = 200 + 40 * Math.sin(t + i * 0.15);
              this.bmCtx.fillStyle = `hsla(${hue}, 80%, 70%, 0.8)`;
              this.bmCtx.fillRect(x, y, barW - 6, bh);

              // Glowing particles
              if (Math.random() < 0.08) {
                this.bmCtx.fillStyle = `hsla(${hue}, 100%, 85%, 0.9)`;
                this.bmCtx.beginPath();
                this.bmCtx.arc(x + barW / 2, y - 10, 4 + Math.random() * 4, 0, Math.PI * 2);
                this.bmCtx.fill();
              }
            }
            requestAnimationFrame(draw);
          };
          draw();
        }

        saveState() {
          const state = {
            e0: this.e0,
            continuityIndex: this.continuityIndex,
            voiceOn: this.voiceOn,
            learningMode: this.learningMode
          };
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        loadState() {
          try {
            const saved = JSON.parse(localStorage.getItem(STORAGE_KEY));
            if (saved) {
              this.e0 = saved.e0 || 0.1;
              this.continuityIndex = saved.continuityIndex || 0.8;
              this.voiceOn = saved.voiceOn || false;
              this.learningMode = saved.learningMode ?? true;
              this.voiceToggle.textContent = this.voiceOn ? "ðŸ”Š Voice: ON" : "ðŸ”Š Voice: OFF";
              this.learningToggle.textContent = this.learningMode ? "ðŸ“š Learning: ON" : "ðŸ“š Learning: OFF";
            }
          } catch (e) {}
        }
      }

      window.addEventListener("DOMContentLoaded", () => {
        window.auraX = new AuraXOmegaEngine();
      });
    })();
  </script>
</body>
</html>