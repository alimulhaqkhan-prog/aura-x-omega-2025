<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AURA-X Œ© ‚Äì Offline Emotional Continuity Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Offline LLM package (WebLLM / MLC) -->
  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";
    window.webllm = webllm;
  </script>

  <style>
    /* RESET & BASICS */
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:
        radial-gradient(circle at 20% 0%, #1e293b 0, transparent 45%),
        radial-gradient(circle at 80% 0%, #0ea5e9 0, transparent 40%),
        linear-gradient(145deg,#020617 0,#020617 40%,#020617 100%);
      color:#e5e7eb;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:20px;
    }
    .app{
      position:relative;
      max-width:960px;
      width:100%;
      background:linear-gradient(145deg,rgba(15,23,42,.96),rgba(15,23,42,.99));
      border-radius:32px;
      padding:24px 24px 28px;
      box-shadow:
        0 20px 40px rgba(15,23,42,.7),
        0 0 0 1px rgba(148,163,184,.25);
      overflow:hidden;
    }
    .app::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(circle at 20% 30%, rgba(56,189,248,.22), transparent 45%),
        radial-gradient(circle at 80% 25%, rgba(34,211,238,.18), transparent 40%),
        linear-gradient(90deg, rgba(56,189,248,.20), transparent 35%, rgba(34,211,238,.18));
      opacity:.9;
      pointer-events:none;
      z-index:0;
    }
    .app-inner{
      position:relative;
      z-index:1;
    }

    /* HEADER */
    .header{
      position:relative;
      border-radius:28px;
      padding:20px 20px 18px;
      background:
        radial-gradient(circle at 0 0, rgba(59,130,246,.45), transparent 60%),
        radial-gradient(circle at 100% 20%, rgba(56,189,248,.4), transparent 55%),
        linear-gradient(135deg,rgba(15,23,42,.95),rgba(15,23,42,.98));
      box-shadow:
        0 0 0 1px rgba(148,163,184,.35),
        0 18px 35px rgba(15,23,42,.9);
      overflow:hidden;
    }
    .header::after{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(90deg,rgba(56,189,248,.18)0 2px,transparent 2px 26px);
      mix-blend-mode:soft-light;
      opacity:.35;
      pointer-events:none;
    }
    .header-main{
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
    }
    .title-block{
      max-width:70%;
    }
    .title{
      font-size:1.9rem;
      letter-spacing:.18em;
      text-transform:uppercase;
      color:#e0f2fe;
      font-weight:700;
      text-shadow:0 0 18px rgba(56,189,248,.8);
    }
    .omega{
      font-size:2.1rem;
      margin-left:4px;
    }
    .subtitle{
      margin-top:4px;
      font-size:.84rem;
      color:#e5e7eb;
      opacity:.9;
    }
    .subtitle span{color:#7dd3fc}

    .header-controls{
      position:relative;
      text-align:right;
    }
    .header-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(15,23,42,.84);
      border:1px solid rgba(148,163,184,.7);
      font-size:.75rem;
      color:#e5e7eb;
      cursor:pointer;
    }
    .header-pill span.dot{
      width:7px;height:7px;border-radius:999px;
      background:radial-gradient(circle at 30% 30%,#a7f3d0,#22c55e);
      box-shadow:0 0 12px rgba(34,197,94,.85);
    }
    .header-controls-menu{
      position:absolute;
      right:0; top:32px;
      width:190px;
      border-radius:16px;
      padding:8px;
      background:rgba(15,23,42,.98);
      box-shadow:
        0 18px 40px rgba(15,23,42,.95),
        0 0 0 1px rgba(148,163,184,.4);
      display:none;
      flex-direction:column;
      gap:4px;
      z-index:20;
    }
    .header-controls-menu.open{display:flex;}
    .header-controls-menu button{
      width:100%;
      border:none;
      background:rgba(15,23,42,.9);
      color:#e5e7eb;
      font-size:.78rem;
      padding:7px 9px;
      border-radius:999px;
      cursor:pointer;
      text-align:left;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .header-controls-menu button span.label{
      display:flex;align-items:center;gap:6px;
    }
    .header-controls-menu button span.badge{
      font-size:.7rem;
      padding:2px 7px;
      border-radius:999px;
      background:rgba(37,99,235,.9);
    }

    .ethic-card{
      margin-top:14px;
      border-radius:20px;
      padding:10px 12px;
      background:linear-gradient(135deg,#111827,#020617);
      border:1px solid rgba(250,204,21,.8);
      box-shadow:0 0 0 1px rgba(161,98,7,.7),0 12px 24px rgba(15,23,42,.9);
      color:#fef9c3;
      font-size:.76rem;
      position:relative;
    }
    .ethic-card::before{
      content:"";
      position:absolute; inset:-1px;
      background:radial-gradient(circle at 10% -10%,rgba(250,250,210,.45),transparent 60%);
      opacity:.7;pointer-events:none;
    }
    .ethic-card strong{color:#fde68a}

    .engine-badge{
      margin-top:10px;
      display:inline-flex;
      padding:9px 18px;
      border-radius:999px;
      background:radial-gradient(circle at 20% 0,#38bdf8,#0ea5e9);
      box-shadow:0 18px 35px rgba(14,165,233,.7);
      color:#0f172a;
      font-weight:600;
      font-size:.8rem;
      text-transform:uppercase;
      letter-spacing:.12em;
    }

    .options-btn{
      margin-top:14px;
      border-radius:999px;
      border:none;
      padding:7px 14px;
      background:rgba(15,23,42,.85);
      color:#e5e7eb;
      font-size:.8rem;
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      box-shadow:0 0 0 1px rgba(148,163,184,.55);
    }

    /* METRICS */
    .section{
      margin-top:18px;
      padding:16px 18px 18px;
      border-radius:24px;
      background:rgba(15,23,42,.95);
      box-shadow:0 0 0 1px rgba(148,163,184,.35);
    }
    .section-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:10px;
      font-size:.8rem;
      color:#9ca3af;
    }
    .section-header strong{color:#e5e7eb}
    .metrics-grid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:10px;
    }
    .metric-card{
      border-radius:18px;
      padding:10px 12px;
      background:radial-gradient(circle at 0 0,rgba(56,189,248,.20),transparent 55%),
                 #020617;
      box-shadow:0 0 0 1px rgba(30,64,175,.7);
    }
    .metric-label{
      font-size:.7rem;
      color:#9ca3af;
      margin-bottom:2px;
    }
    .metric-value{
      font-size:1.2rem;
      font-weight:600;
      color:#e0f2fe;
    }
    .metric-sub{
      margin-top:2px;
      font-size:.7rem;
      color:#9ca3af;
    }
    .metric-chips{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      font-size:.7rem;
    }
    .chip{
      padding:3px 9px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.5);
      background:rgba(15,23,42,.95);
    }

    /* BM CHART */
    .bm-chart{
      width:100%;
      height:110px;
      border-radius:18px;
      background:radial-gradient(circle at 0 0,rgba(56,189,248,.20),transparent 55%),
                 #020617;
      box-shadow:0 0 0 1px rgba(30,64,175,.7);
      position:relative;
      overflow:hidden;
    }
    .bm-chart canvas{
      width:100%;
      height:100%;
      display:block;
    }
    .bm-foot{
      margin-top:8px;
      font-size:.7rem;
      color:#9ca3af;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    /* CONSOLE */
    .console-shell{
      border-radius:22px;
      background:#020617;
      box-shadow:0 0 0 1px rgba(30,64,175,.65);
      overflow:hidden;
    }
    .console-header{
      padding:9px 12px;
      border-bottom:1px solid rgba(30,64,175,.8);
      font-size:.75rem;
      color:#9ca3af;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .console-body{
      padding:10px 12px 12px;
      max-height:220px;
      overflow-y:auto;
      font-family:"JetBrains Mono","SF Mono",ui-monospace,monospace;
      font-size:.78rem;
      color:#e5e7eb;
      background:radial-gradient(circle at 0 0,rgba(15,23,42,1),rgba(15,23,42,.98));
    }
    .console-line{
      margin-bottom:4px;
      white-space:pre-wrap;
      word-break:break-word;
    }
    .console-line span.role{
      color:#60a5fa;
    }
    .console-line span.time{
      color:#6b7280;
      font-size:.7rem;
    }

    .formula-banner{
      margin-top:10px;
      border-radius:999px;
      background:linear-gradient(120deg,#020617,#0f172a);
      box-shadow:0 0 0 1px rgba(56,189,248,.7);
      padding:7px 12px;
      font-family:"JetBrains Mono","SF Mono",ui-monospace,monospace;
      font-size:.78rem;
      color:#e0f2fe;
      overflow-x:auto;
      white-space:nowrap;
    }

    .input-row{
      margin-top:10px;
      display:flex;
      gap:8px;
    }
    .input-row input{
      flex:1;
      border-radius:999px;
      border:none;
      padding:9px 14px;
      font-size:.85rem;
      background:rgba(15,23,42,.95);
      color:#e5e7eb;
      box-shadow:0 0 0 1px rgba(55,65,81,.8);
    }
    .input-row input::placeholder{color:#6b7280}
    .send-btn{
      border:none;
      border-radius:999px;
      padding:0 18px;
      background:linear-gradient(135deg,#0ea5e9,#22c55e);
      color:#0f172a;
      font-weight:600;
      font-size:.86rem;
      cursor:pointer;
      box-shadow:0 12px 26px rgba(14,165,233,.7);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .pipes-note{
      margin-top:4px;
      font-size:.7rem;
      color:#9ca3af;
    }

    /* SMALL BUTTONS */
    .btn-mini{
      border:none;
      border-radius:999px;
      padding:4px 9px;
      font-size:.7rem;
      background:rgba(15,23,42,.9);
      color:#e5e7eb;
      box-shadow:0 0 0 1px rgba(148,163,184,.55);
      cursor:pointer;
    }

    /* MODALS (simple centered) */
    .modal-overlay{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.80);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:40;
      padding:14px;
    }
    .modal-overlay.visible{display:flex;}
    .modal-card{
      width:100%;
      max-width:520px;
      max-height:90vh;
      border-radius:22px;
      background:#020617;
      box-shadow:
        0 24px 55px rgba(0,0,0,.9),
        0 0 0 1px rgba(148,163,184,.55);
      padding:16px 16px 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .modal-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.84rem;
      color:#e5e7eb;
    }
    .modal-sub{
      font-size:.74rem;
      color:#9ca3af;
    }
    .modal-body{
      flex:1;
      border-radius:16px;
      background:#020617;
      box-shadow:inset 0 0 0 1px rgba(31,41,55,.9);
      padding:10px;
      overflow:auto;
      font-size:.78rem;
    }
    .modal-actions{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      font-size:.76rem;
    }
    .modal-close{
      border:none;
      background:none;
      color:#9ca3af;
      font-size:1.1rem;
      cursor:pointer;
    }
    .modal-search{
      width:100%;
      border-radius:999px;
      border:none;
      padding:8px 12px;
      font-size:.8rem;
      background:#020617;
      color:#e5e7eb;
      box-shadow:0 0 0 1px rgba(55,65,81,.9);
      margin-bottom:8px;
    }

    /* LLM modal extras */
    .offline-card{
      border-radius:16px;
      padding:10px 12px;
      background:radial-gradient(circle at 0 0,rgba(56,189,248,.24),transparent 60%),#020617;
      box-shadow:0 0 0 1px rgba(37,99,235,.8);
      font-size:.76rem;
      margin-bottom:8px;
    }
    .offline-title{
      font-weight:600;
      margin-bottom:4px;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .offline-sub{
      color:#bfdbfe;
      margin-bottom:6px;
    }
    .offline-btn{
      border:none;
      border-radius:999px;
      padding:6px 12px;
      font-size:.78rem;
      background:linear-gradient(135deg,#22c55e,#10b981);
      color:#022c22;
      font-weight:600;
      cursor:pointer;
      box-shadow:0 10px 20px rgba(16,185,129,.6);
    }
    .offline-status{
      margin-top:5px;
      font-size:.72rem;
      color:#bbf7d0;
    }
    .offline-progress{
      margin-top:4px;
      width:100%;
      height:4px;
      border-radius:999px;
      background:#020617;
      overflow:hidden;
      box-shadow:inset 0 0 0 1px rgba(31,41,55,1);
    }
    .offline-progress-bar{
      height:100%;
      width:0%;
      border-radius:999px;
      background:linear-gradient(90deg,#22c55e,#0ea5e9);
    }
    .offline-toggle-row{
      margin-top:6px;
      display:flex;
      align-items:center;
      gap:6px;
      font-size:.72rem;
      color:#e5e7eb;
    }
    .faith-note{
      font-size:.72rem;
      color:#9ca3af;
      margin-bottom:4px;
    }

    .faith-grid{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:8px;
    }
    .faith-pill{
      border-radius:999px;
      border:1px solid rgba(148,163,184,.6);
      padding:4px 9px;
      font-size:.74rem;
      background:#020617;
      cursor:pointer;
    }
    .faith-pill.active{
      background:linear-gradient(135deg,#38bdf8,#22c55e);
      color:#022c22;
      border-color:transparent;
    }

    .seed-textarea{
      width:100%;
      min-height:220px;
      border-radius:14px;
      border:none;
      padding:8px 10px;
      font-family:"JetBrains Mono","SF Mono",ui-monospace,monospace;
      font-size:.78rem;
      background:#020617;
      color:#e5e7eb;
      box-shadow:inset 0 0 0 1px rgba(31,41,55,1);
    }

    .tag-row{
      margin-top:6px;
      font-size:.72rem;
      color:#9ca3af;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    @media(max-width:720px){
      .app{padding:16px}
      .header-main{flex-direction:column;gap:8px;}
      .title-block{max-width:100%}
      .metrics-grid{grid-template-columns:1fr;}
    }

    .hidden{display:none;}
  </style>
</head>
<body>
<div class="app">
  <div class="app-inner">
    <!-- HEADER -->
    <div class="header">
      <div class="header-main">
        <div class="title-block">
          <div class="title">AURA-X <span class="omega">Œ©</span></div>
          <div class="subtitle">
            Offline emotional continuity engine (prototype).
            <span>TM = your inputs only ¬∑ Internal layers keep continuity and trajectory.</span>
          </div>
          <div class="ethic-card">
            <strong>Universal ethic:</strong>
            avoid actions that grow negative emotions in you or others.
            Move gently toward choices that increase shared positive feeling for everyone.
          </div>
          <div class="engine-badge">
            EMOTIONAL CONTINUITY ENGINE ACTIVE
          </div>
        </div>

        <div class="header-controls">
          <button id="headerToggle" class="header-pill">
            <span class="dot"></span>
            <span>Engine online</span>
          </button>
          <div id="headerControlsMenu" class="header-controls-menu">
            <button id="voiceToggleBtn">
              <span class="label">üîä Voice</span>
              <span class="badge" id="voiceBadge">ON</span>
            </button>
            <button id="intelToggleBtn">
              <span class="label">üß† Intelligence</span>
              <span class="badge" id="intelBadge">ON</span>
            </button>
            <button id="feedSeedBtn">
              <span class="label">üå± Feed the seed</span>
            </button>
            <button id="learningToggleBtn">
              <span class="label">üìö Learning</span>
              <span class="badge" id="learningBadge">ON</span>
            </button>
            <button id="faithBtn">
              <span class="label">üïä Faith lens</span>
              <span class="badge" id="faithBadge">None</span>
            </button>
            <button id="llmBtn">
              <span class="label">ü§ñ LLM link</span>
              <span class="badge" id="llmBadge">OFF</span>
            </button>
          </div>
        </div>
      </div>

      <button id="optionsBtn" class="options-btn">
        ‚öôÔ∏è Options
      </button>
    </div>

    <!-- EMOTIONAL METRICS -->
    <div class="section">
      <div class="section-header">
        <strong>Emotional metrics</strong>
        <span>Internal state based on TM, BM, intelligence and optional helper LLM.</span>
      </div>
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-label">Emotional state E‚ÇÄ</div>
          <div id="metricE0" class="metric-value">0.00</div>
          <div class="metric-sub">tanh-based, range [-1, +1]</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">TM activation (user only)</div>
          <div id="metricTM" class="metric-value">0.00</div>
          <div class="metric-sub">Recent user inputs (text/voice/docs)</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">BM resonance</div>
          <div id="metricBM" class="metric-value">0.00</div>
          <div class="metric-sub">Stored emotional events</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Continuity index</div>
          <div id="metricC" class="metric-value">1.000</div>
          <div class="metric-sub">Stability of emotional trajectory</div>
        </div>
      </div>
      <div class="metric-chips">
        <span id="chipValence" class="chip">VALENCE: neutral</span>
        <span id="chipArousal" class="chip">AROUSAL: moderate</span>
        <span id="chipReaction" class="chip">REACTION: balanced</span>
      </div>
    </div>

    <!-- BOLD MEMORY LAYERS -->
    <div class="section">
      <div class="section-header">
        <strong>Bold Memory layers</strong>
        <span>Only story-level memories for future photo/video scenes.</span>
      </div>
      <div class="bm-chart">
        <canvas id="bmCanvas"></canvas>
      </div>
      <div class="bm-foot">
        <span id="bmFootText">Active layers: 0 / 240 ¬∑ System online</span>
        <button id="bmRecallBtn" class="btn-mini">Recall from BM</button>
      </div>
    </div>

    <!-- CONSOLE -->
    <div class="section">
      <div class="section-header">
        <strong>Emotional continuity console</strong>
        <span>Offline-first ¬∑ TM = your inputs only ¬∑ Small-talk never goes to BM.</span>
      </div>

      <div class="console-shell">
        <div class="console-header">
          <span>AURA-X Œ© CONVERSATION</span>
          <div style="display:flex;gap:6px;">
            <button id="historyBtn" class="btn-mini">History</button>
          </div>
        </div>
        <div id="consoleLog" class="console-body"></div>
      </div>

      <div class="formula-banner">
        E‚ÇÄ = tanh( R(TM, BM) + I(TM) + I_intel + I_LLM ‚àí D + Œª_faith + Œª_sys + Œª_trc )
      </div>

      <div class="input-row">
        <input id="userInput" type="text"
               placeholder="Talk to AURA-X Œ©‚Ä¶ (TM = your conversation, kept offline in this browser)" />
        <button id="sendBtn" class="send-btn">Send</button>
      </div>
      <div class="pipes-note">
        Pipeline: TM (your inputs) ‚Üí local rules + seeds ‚Üí BM resonance & intelligence ‚Üí full formula ‚Üí optional helper LLM ‚Üí answer + updated emotional metrics.
      </div>
    </div>
  </div>
</div>

<!-- CONVERSATION HISTORY MODAL -->
<div id="historyModal" class="modal-overlay">
  <div class="modal-card">
    <div class="modal-header">
      <div>
        <strong>Conversation history</strong>
        <div class="modal-sub">Recent TM log (user + system messages).</div>
      </div>
      <button class="modal-close" data-close="historyModal">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="modal-sub" style="margin-bottom:6px;">
        Entries are stored only in this browser (localStorage). You can clear them any time.
      </div>
      <div id="historyBody" style="font-size:.78rem;white-space:pre-wrap;"></div>
    </div>
    <div class="modal-actions">
      <button id="historyDelete48" class="btn-mini">Delete history last 48h</button>
      <button id="historyDeleteAll" class="btn-mini">Delete all history</button>
    </div>
  </div>
</div>

<!-- BM RECALL MODAL -->
<div id="bmModal" class="modal-overlay">
  <div class="modal-card">
    <div class="modal-header">
      <div>
        <strong>Recall from BM</strong>
        <div class="modal-sub">Only long stories and scenes (photo/video-ready).</div>
      </div>
      <button class="modal-close" data-close="bmModal">‚úï</button>
    </div>
    <div class="modal-body">
      <input id="bmSearchInput" class="modal-search"
             placeholder='Search by keyword (e.g., "city", "mother", "court", "hope")' />
      <div id="bmList" style="font-size:.78rem;"></div>
    </div>
  </div>
</div>

<!-- FEED THE SEED MODAL -->
<div id="seedModal" class="modal-overlay">
  <div class="modal-card">
    <div class="modal-header">
      <div>
        <strong>üå± Feed the seed (protected)</strong>
        <div class="modal-sub">
          Add LaTeX Q ‚Üí A blocks directly into intelligence memory.
        </div>
      </div>
      <button class="modal-close" data-close="seedModal">‚úï</button>
    </div>
    <div class="modal-body">
      <textarea id="seedInput" class="seed-textarea"
        placeholder="Paste a LaTeX block with \item questions and \textbf{A:} answers.
Optional metadata at the start of each answer:
[polarity=positive; code=E031; intensity=0.8; category=hope]"></textarea>
      <div class="tag-row">
        <span>Only you can edit this in this browser.</span>
        <span id="seedStatus">Waiting for block‚Ä¶</span>
      </div>
    </div>
    <div class="modal-actions">
      <button id="seedParseBtn" class="btn-mini">Parse block</button>
      <button id="seedSaveBtn" class="btn-mini">Save to seed</button>
    </div>
  </div>
</div>

<!-- FAITH MODAL -->
<div id="faithModal" class="modal-overlay">
  <div class="modal-card">
    <div class="modal-header">
      <div>
        <strong>AURA-X Œ© options</strong>
        <div class="modal-sub">Optional faith lenses for encouragement lines.</div>
      </div>
      <button class="modal-close" data-close="faithModal">‚úï</button>
    </div>
    <div class="modal-body">
      <p class="faith-note">
        Universal ethics are always active. You can optionally pick one or more faith lenses.
        Nothing is sent to any server.
      </p>
      <div id="faithGrid" class="faith-grid">
        <button class="faith-pill" data-faith="none">None</button>
        <button class="faith-pill" data-faith="Islam">Islam</button>
        <button class="faith-pill" data-faith="Christianity">Christianity</button>
        <button class="faith-pill" data-faith="Hinduism">Hinduism</button>
        <button class="faith-pill" data-faith="Buddhism">Buddhism</button>
        <button class="faith-pill" data-faith="Sikhism">Sikhism</button>
        <button class="faith-pill" data-faith="Judaism">Judaism</button>
        <button class="faith-pill" data-faith="Atheism / Humanism">Atheism / Humanism</button>
        <button class="faith-pill" data-faith="Other / Mixed">Other / Mixed</button>
        <button class="faith-pill" data-faith="Indigenous / Traditional">Indigenous / Traditional</button>
        <button class="faith-pill" data-faith="Eastern / Chinese">Eastern / Chinese</button>
      </div>
    </div>
  </div>
</div>

<!-- LLM LINK MODAL -->
<div id="llmModal" class="modal-overlay">
  <div class="modal-card">
    <div class="modal-header">
      <div>
        <strong>ü§ñ LLM link & offline engine</strong>
        <div class="modal-sub">
          Password 6789 ¬∑ Keys stay inside this browser only.
        </div>
      </div>
      <button class="modal-close" data-close="llmModal">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="offline-card">
        <div class="offline-title">
          OFFLINE MODE: In-browser model (WebGPU).
        </div>
        <div class="offline-sub">
          Suggested demo: <strong>Llama-3.2-1B-Instruct</strong> (~1.3 GB, downloaded once, then runs fully offline).
        </div>
        <button id="offlineLoadBtn" class="offline-btn">üì• Download / load model</button>
        <div id="offlineStatus" class="offline-status">Status: Not loaded</div>
        <div class="offline-progress">
          <div id="offlineProgressBar" class="offline-progress-bar"></div>
        </div>
        <div class="offline-toggle-row">
          <input type="checkbox" id="offlineLLMCheckbox" />
          <label for="offlineLLMCheckbox">Use offline model when online LLM is off or fails</label>
        </div>
      </div>

      <p class="faith-note" style="margin-bottom:4px;">
        Cloud API (optional). You can connect any compatible LLM endpoint here.
        For real products, move calls to a secure backend.
      </p>
      <label style="font-size:.75rem;color:#4b5563;display:block;margin-bottom:4px;">API base URL</label>
      <input id="llmBaseUrlInput" class="modal-search"
             placeholder="https://your-llm-endpoint.example.com/v1/chat/completions" />
      <label style="font-size:.75rem;color:#4b5563;display:block;margin-bottom:4px;">Model name (optional)</label>
      <input id="llmModelInput" class="modal-search" placeholder="my-model-name" />
      <label style="font-size:.75rem;color:#4b5563;display:block;margin-bottom:4px;">API key</label>
      <input id="llmKeyInput" class="modal-search" placeholder="sk-‚Ä¶" />

      <div class="modal-actions" style="justify-content:space-between;margin-top:8px;">
        <div>
          <button id="llmSaveBtn" class="btn-mini">Save settings</button>
          <button id="llmClearBtn" class="btn-mini">Clear key</button>
        </div>
        <button id="llmToggleBtn" class="btn-mini">LLM: OFF</button>
      </div>
      <div id="llmStatusText" style="font-size:.73rem;color:#4b5563;margin-top:6px;">
        No online API key saved. Engine is offline-only.
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const STORAGE_KEY   = "auraXOmegaState_v11";
  const TM_KEY        = "auraXOmegaTM_v11";
  const BM_KEY        = "auraXOmegaBM_v11";
  const SEED_KEY      = "auraXOmegaSeeds_v11";
  const LLM_CONFIG_KEY= "auraXOmegaLLM_v11";

  const BM_CAPACITY   = 240;
  const BM_AUTO_DAYS  = 30;               // auto prune after ~1 month
  const DAY_MS        = 24*60*60*1000;

  const OFFLINE_MODEL_ID = "Llama-3.2-1B-Instruct-q4f32_1-MLC";

  function now(){ return Date.now(); }
  function clamp(v,min,max){return v<min?min:v>max?max:v;}
  function tanh(x){return Math.tanh?Math.tanh(x):(Math.exp(x)-Math.exp(-x))/(Math.exp(x)+Math.exp(-x));}

  function formatTime(ts){
    const d = new Date(ts);
    return d.toTimeString().slice(0,5);
  }

  function softWordSet(text){
    return (text||"")
      .toLowerCase()
      .replace(/[^a-z0-9\s\u0600-\u06FF]+/g," ")
      .split(/\s+/)
      .filter(w=>w.length>2);
  }
  function topicKey(text){
    const words = softWordSet(text).slice(0,6);
    return words.join("|");
  }

  class AuraXOmegaEngine{
    constructor(){
      this.voiceOn = true;
      this.intelOn = true;
      this.learningOn = true;
      this.allowHelperLLM = true;
      this.faithLens = ["None"];
      this.tmLog = [];
      this.bm = [];
      this.seeds = [];
      this.offlineEngine = null;
      this.offlineLLMStatus = "idle"; // idle | loading | ready | error
      this.offlineLLMEnabled = false;
      this.offlineProgress = 0;
      this.offlineProgressText = "";
      this.llmOnlineEnabled = false;
      this.llmConfig = {baseUrl:"",model:"",key:""};

      this.e0 = 0;
      this.tmActivation = 0;
      this.bmResonance = 0;
      this.continuityIndex = 1;

      this.cacheDom();
      this.bindEvents();
      this.loadState();
      this.renderAll();
      this.bootGreeting();
    }

    cacheDom(){
      this.headerToggle = document.getElementById("headerToggle");
      this.headerControls = document.getElementById("headerControlsMenu");
      this.voiceToggleBtn = document.getElementById("voiceToggleBtn");
      this.voiceBadge = document.getElementById("voiceBadge");
      this.intelToggleBtn = document.getElementById("intelToggleBtn");
      this.intelBadge = document.getElementById("intelBadge");
      this.learningToggleBtn = document.getElementById("learningToggleBtn");
      this.learningBadge = document.getElementById("learningBadge");
      this.feedSeedButton = document.getElementById("feedSeedBtn");
      this.faithBtn = document.getElementById("faithBtn");
      this.faithBadge = document.getElementById("faithBadge");
      this.llmBtn = document.getElementById("llmBtn");
      this.llmBadge = document.getElementById("llmBadge");

      this.metricE0 = document.getElementById("metricE0");
      this.metricTM = document.getElementById("metricTM");
      this.metricBM = document.getElementById("metricBM");
      this.metricC  = document.getElementById("metricC");
      this.chipValence = document.getElementById("chipValence");
      this.chipArousal = document.getElementById("chipArousal");
      this.chipReaction = document.getElementById("chipReaction");

      this.bmCanvas = document.getElementById("bmCanvas");
      this.bmFootText = document.getElementById("bmFootText");

      this.consoleLog = document.getElementById("consoleLog");
      this.userInput = document.getElementById("userInput");
      this.sendBtn = document.getElementById("sendBtn");

      this.historyBtn = document.getElementById("historyBtn");
      this.historyModal = document.getElementById("historyModal");
      this.historyBody = document.getElementById("historyBody");
      this.historyDelete48 = document.getElementById("historyDelete48");
      this.historyDeleteAll = document.getElementById("historyDeleteAll");

      this.bmRecallBtn = document.getElementById("bmRecallBtn");
      this.bmModal = document.getElementById("bmModal");
      this.bmSearchInput = document.getElementById("bmSearchInput");
      this.bmList = document.getElementById("bmList");

      this.seedModal = document.getElementById("seedModal");
      this.seedInput = document.getElementById("seedInput");
      this.seedStatus = document.getElementById("seedStatus");
      this.seedParseBtn = document.getElementById("seedParseBtn");
      this.seedSaveBtn = document.getElementById("seedSaveBtn");

      this.faithModal = document.getElementById("faithModal");
      this.faithGrid = document.getElementById("faithGrid");

      this.llmModal = document.getElementById("llmModal");
      this.llmBaseUrlInput = document.getElementById("llmBaseUrlInput");
      this.llmModelInput = document.getElementById("llmModelInput");
      this.llmKeyInput = document.getElementById("llmKeyInput");
      this.llmSaveBtn = document.getElementById("llmSaveBtn");
      this.llmClearBtn = document.getElementById("llmClearBtn");
      this.llmToggleBtn = document.getElementById("llmToggleBtn");
      this.llmStatusText = document.getElementById("llmStatusText");

      this.offlineLoadBtn = document.getElementById("offlineLoadBtn");
      this.offlineStatus = document.getElementById("offlineStatus");
      this.offlineLLMCheckbox = document.getElementById("offlineLLMCheckbox");
      this.offlineProgressBar = document.getElementById("offlineProgressBar");

      this.optionsBtn = document.getElementById("optionsBtn");

      if(this.bmCanvas){
        this.bmCtx = this.bmCanvas.getContext("2d");
        this.resizeCanvas();
        window.addEventListener("resize",()=>this.resizeCanvas());
      }
    }

    bindEvents(){
      if(this.headerToggle){
        this.headerToggle.addEventListener("click",(e)=>{
          e.stopPropagation();
          this.headerControls.classList.toggle("open");
        });
      }
      document.addEventListener("click",(e)=>{
        if(this.headerControls && !this.headerControls.contains(e.target)){
          this.headerControls.classList.remove("open");
        }
      });

      if(this.optionsBtn){
        this.optionsBtn.addEventListener("click",()=>{
          this.headerControls.classList.toggle("open");
        });
      }

      if(this.sendBtn){
        this.sendBtn.addEventListener("click",()=>this.handleSend());
      }
      if(this.userInput){
        this.userInput.addEventListener("keydown",(e)=>{
          if(e.key==="Enter"){e.preventDefault();this.handleSend();}
        });
      }

      if(this.voiceToggleBtn){
        this.voiceToggleBtn.addEventListener("click",()=>{
          this.voiceOn = !this.voiceOn;
          this.updateVoiceBadge();
          this.saveState();
        });
      }
      if(this.intelToggleBtn){
        this.intelToggleBtn.addEventListener("click",()=>{
          this.intelOn = !this.intelOn;
          this.updateIntelBadge();
          this.saveState();
        });
      }
      if(this.learningToggleBtn){
        this.learningToggleBtn.addEventListener("click",()=>{
          this.learningOn = !this.learningOn;
          this.updateLearningBadge();
          this.saveState();
        });
      }

      if(this.historyBtn){
        this.historyBtn.addEventListener("click",()=>this.openHistoryModal());
      }
      if(this.historyDelete48){
        this.historyDelete48.addEventListener("click",()=>{
          this.pruneTM48h();
          this.renderHistory();
          this.saveTM();
        });
      }
      if(this.historyDeleteAll){
        this.historyDeleteAll.addEventListener("click",()=>{
          this.tmLog = [];
          this.renderHistory();
          this.renderConsole();
          this.saveTM();
        });
      }

      if(this.bmRecallBtn){
        this.bmRecallBtn.addEventListener("click",()=>this.openBMModal());
      }
      if(this.bmSearchInput){
        this.bmSearchInput.addEventListener("input",()=>this.renderBMList());
      }

      if(this.feedSeedButton){
        this.feedSeedButton.addEventListener("click",()=>this.openSeedModal());
      }
      if(this.seedParseBtn){
        this.seedParseBtn.addEventListener("click",()=>this.parseSeedBlock());
      }
      if(this.seedSaveBtn){
        this.seedSaveBtn.addEventListener("click",()=>this.saveSeeds());
      }

      if(this.faithBtn){
        this.faithBtn.addEventListener("click",()=>this.openFaithModal());
      }
      if(this.faithGrid){
        this.faithGrid.addEventListener("click",(e)=>{
          const btn = e.target.closest(".faith-pill");
          if(!btn) return;
          const value = btn.dataset.faith;
          if(value === "none"){
            this.faithLens = ["None"];
          }else{
            this.faithLens = [value];
          }
          this.updateFaithUI();
          this.saveState();
        });
      }

      if(this.llmBtn){
        this.llmBtn.addEventListener("click",()=>this.openLLMModal());
      }
      if(this.llmSaveBtn){
        this.llmSaveBtn.addEventListener("click",()=>{
          this.llmConfig.baseUrl = (this.llmBaseUrlInput.value||"").trim();
          this.llmConfig.model   = (this.llmModelInput.value||"").trim();
          this.llmConfig.key     = (this.llmKeyInput.value||"").trim();
          this.saveLLMConfig();
          this.updateLLMUI();
        });
      }
      if(this.llmClearBtn){
        this.llmClearBtn.addEventListener("click",()=>{
          this.llmConfig.key = "";
          this.llmKeyInput.value = "";
          this.saveLLMConfig();
          this.updateLLMUI();
        });
      }
      if(this.llmToggleBtn){
        this.llmToggleBtn.addEventListener("click",()=>{
          this.llmOnlineEnabled = !this.llmOnlineEnabled;
          this.updateLLMUI();
          this.saveState();
        });
      }

      if(this.offlineLoadBtn){
        this.offlineLoadBtn.addEventListener("click",async ()=>{
          await this.handleOfflineLoad();
        });
      }
      if(this.offlineLLMCheckbox){
        this.offlineLLMCheckbox.addEventListener("change",()=>{
          this.offlineLLMEnabled = this.offlineLLMCheckbox.checked;
          this.updateLLMUI();
          this.saveState();
        });
      }

      document.querySelectorAll(".modal-close").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id = btn.getAttribute("data-close");
          if(id){
            const modal = document.getElementById(id);
            if(modal) modal.classList.remove("visible");
          }
        });
      });
    }

    /* ------------ STATE LOAD/SAVE ------------- */
    loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(raw){
          const obj = JSON.parse(raw);
          this.voiceOn = obj.voiceOn ?? this.voiceOn;
          this.intelOn = obj.intelOn ?? this.intelOn;
          this.learningOn = obj.learningOn ?? this.learningOn;
          this.faithLens = obj.faithLens ?? this.faithLens;
          this.offlineLLMEnabled = obj.offlineLLMEnabled ?? this.offlineLLMEnabled;
          this.llmOnlineEnabled = obj.llmOnlineEnabled ?? this.llmOnlineEnabled;
        }
      }catch(e){console.warn("state load error",e);}
      try{
        const rawTM = localStorage.getItem(TM_KEY);
        if(rawTM){ this.tmLog = JSON.parse(rawTM); }
      }catch(e){}
      try{
        const rawBM = localStorage.getItem(BM_KEY);
        if(rawBM){ this.bm = JSON.parse(rawBM); }
      }catch(e){}
      try{
        const rawSeed = localStorage.getItem(SEED_KEY);
        if(rawSeed){ this.seeds = JSON.parse(rawSeed); }
      }catch(e){}
      try{
        const rawCfg = localStorage.getItem(LLM_CONFIG_KEY);
        if(rawCfg){ this.llmConfig = JSON.parse(rawCfg); }
      }catch(e){}
    }

    saveState(){
      const obj = {
        voiceOn:this.voiceOn,
        intelOn:this.intelOn,
        learningOn:this.learningOn,
        faithLens:this.faithLens,
        offlineLLMEnabled:this.offlineLLMEnabled,
        llmOnlineEnabled:this.llmOnlineEnabled
      };
      try{ localStorage.setItem(STORAGE_KEY,JSON.stringify(obj)); }catch(e){}
      this.saveTM();
      this.saveBM();
      this.saveLLMConfig();
    }
    saveTM(){
      try{ localStorage.setItem(TM_KEY,JSON.stringify(this.tmLog)); }catch(e){}
    }
    saveBM(){
      try{ localStorage.setItem(BM_KEY,JSON.stringify(this.bm)); }catch(e){}
    }
    saveLLMConfig(){
      try{ localStorage.setItem(LLM_CONFIG_KEY,JSON.stringify(this.llmConfig)); }catch(e){}
    }

    /* ------------ RENDER ------------ */
    renderAll(){
      this.updateVoiceBadge();
      this.updateIntelBadge();
      this.updateLearningBadge();
      this.updateFaithUI();
      this.updateLLMUI();
      this.renderConsole();
      this.updateEmotionalMetrics();
      this.drawBMChart();
      this.updateBMFoot();
    }

    updateVoiceBadge(){
      if(!this.voiceBadge) return;
      this.voiceBadge.textContent = this.voiceOn ? "ON" : "OFF";
    }
    updateIntelBadge(){
      if(!this.intelBadge) return;
      this.intelBadge.textContent = this.intelOn ? "ON" : "OFF";
    }
    updateLearningBadge(){
      if(!this.learningBadge) return;
      this.learningBadge.textContent = this.learningOn ? "ON" : "OFF";
    }
    updateFaithUI(){
      if(this.faithBadge){
        this.faithBadge.textContent = this.faithLens.join(", ");
      }
      if(this.faithGrid){
        this.faithGrid.querySelectorAll(".faith-pill").forEach(p=>{
          const value = p.dataset.faith;
          const active = (value==="none" && this.faithLens[0]==="None") ||
                         this.faithLens.includes(value);
          p.classList.toggle("active",active);
        });
      }
    }
    updateLLMUI(){
      if(this.llmBadge){
        const mode = this.offlineLLMEnabled ? "OFFLINE" : (this.llmOnlineEnabled?"ONLINE":"OFF");
        this.llmBadge.textContent = mode;
      }
      if(this.llmToggleBtn){
        this.llmToggleBtn.textContent = this.llmOnlineEnabled ? "LLM: ON" : "LLM: OFF";
      }
      if(this.offlineStatus){
        let txt = "Status: ";
        if(this.offlineLLMStatus==="idle") txt += "Not loaded";
        else if(this.offlineLLMStatus==="loading") txt += "Loading‚Ä¶";
        else if(this.offlineLLMStatus==="ready") txt += "Model ready";
        else if(this.offlineLLMStatus==="error") txt += "Error ‚Äì see console";
        this.offlineStatus.textContent = txt + (this.offlineProgressText?(" ¬∑ "+this.offlineProgressText):"");
      }
      if(this.offlineProgressBar){
        this.offlineProgressBar.style.width = Math.round(this.offlineProgress*100)+"%";
      }
      if(this.offlineLLMCheckbox){
        this.offlineLLMCheckbox.checked = this.offlineLLMEnabled;
      }
      if(this.llmStatusText){
        if(this.llmConfig.key){
          this.llmStatusText.textContent = "Online LLM configured. Calls are still local-first and rare.";
        }else{
          this.llmStatusText.textContent = "No online API key saved. Engine is offline-only.";
        }
      }
      if(this.llmBaseUrlInput && !this.llmBaseUrlInput.value){
        this.llmBaseUrlInput.value = this.llmConfig.baseUrl||"";
      }
      if(this.llmModelInput && !this.llmModelInput.value){
        this.llmModelInput.value = this.llmConfig.model||"";
      }
      if(this.llmKeyInput && !this.llmKeyInput.value){
        this.llmKeyInput.value = this.llmConfig.key||"";
      }
    }

    renderConsole(){
      if(!this.consoleLog) return;
      this.consoleLog.innerHTML = "";
      this.tmLog.slice(-80).forEach(entry=>{
        const div = document.createElement("div");
        div.className = "console-line";
        const role = document.createElement("span");
        role.className = "role";
        role.textContent = entry.role==="user" ? "you" : "ai";
        const time = document.createElement("span");
        time.className = "time";
        time.textContent = " ¬∑ " + formatTime(entry.ts);
        const body = document.createElement("span");
        body.textContent = "  " + entry.text;
        div.appendChild(role);
        div.appendChild(time);
        div.appendChild(body);
        this.consoleLog.appendChild(div);
      });
      this.consoleLog.scrollTop = this.consoleLog.scrollHeight;
    }

    resizeCanvas(){
      if(!this.bmCanvas) return;
      const rect = this.bmCanvas.getBoundingClientRect();
      this.bmCanvas.width = rect.width*2;
      this.bmCanvas.height = rect.height*2;
      if(this.bmCtx){
        this.bmCtx.scale(2,2);
        this.drawBMChart();
      }
    }

    drawBMChart(){
      if(!this.bmCtx) return;
      const ctx = this.bmCtx;
      const canvas = this.bmCanvas;
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "#020617";
      ctx.fillRect(0,0,w,h);

      const n = this.bm.length;
      if(!n) return;
      const step = Math.max(w / BM_CAPACITY, 2);
      const maxH = h-6;
      ctx.fillStyle = "rgba(56,189,248,0.85)";
      this.bm.forEach((m,i)=>{
        const ageDays = (now()-m.ts)/DAY_MS;
        const ageFactor = Math.exp(-ageDays/60);
        const val = Math.abs(m.intensity||0.5);
        const hBar = 4 + maxH*clamp(val*ageFactor,0,1);
        const x = i*step;
        const y = h - hBar;
        ctx.fillRect(x,y,step-1,hBar);
      });
    }

    updateBMFoot(){
      if(!this.bmFootText) return;
      const active = this.bm.length;
      this.bmFootText.textContent = `Active layers: ${active}/${BM_CAPACITY} ¬∑ System online`;
    }

    updateEmotionalMetrics(){
      // TM activation: based on last few user messages length and sentiment words
      const recentUser = this.tmLog.filter(m=>m.role==="user").slice(-10);
      let tmScore = 0;
      recentUser.forEach((m,i)=>{
        const recency = 1 - (i/10);
        const lenFactor = Math.min(m.text.length/200,1);
        const polarity = this.estimatePolarity(m.text);
        tmScore += recency * lenFactor * polarity;
      });
      this.tmActivation = clamp(tmScore, -1, 1);

      // BM resonance: weighted by intensity, recency and locked-ness
      let bmScore = 0;
      this.bm.forEach(m=>{
        const ageDays = (now()-m.ts)/DAY_MS;
        const rec = Math.exp(-ageDays/60);
        const pol = m.polarity==="negative" ? -1 : (m.polarity==="positive"?1:0);
        const lockedBoost = m.locked ? 1.2 : 1;
        bmScore += rec * (m.intensity||0.5) * pol * lockedBoost;
      });
      this.bmResonance = clamp(bmScore/Math.max(this.bm.length||1,1),-1,1);

      // R(TM,BM): simple product of TM and BM channels
      const R = this.tmActivation * this.bmResonance;

      // I(TM): magnitude of TM activity
      const I_TM = Math.abs(this.tmActivation)*0.8;

      // I_intel: if seeds / rules hit often recently, boost
      const recentAI = this.tmLog.slice(-10).filter(m=>m.source==="seed").length;
      const I_intel = clamp(recentAI/5,0,1)*0.6;

      // I_LLM: small term when helper LLM used
      const recentLLM = this.tmLog.slice(-10).filter(m=>m.source==="llm").length;
      const I_LLM = clamp(recentLLM/5,0,1)*0.4;

      // Decay D: older BM + inactivity
      const avgAgeDays = this.bm.length
        ? this.bm.reduce((s,m)=>s+((now()-m.ts)/DAY_MS),0)/this.bm.length
        : 0;
      const D = clamp(avgAgeDays/90,0,1) + (recentUser.length?0:0.2);

      // Œª_faith: soft positive bias when any faith lens selected
      const lambdaFaith = (this.faithLens[0] && this.faithLens[0]!=="None") ? 0.25 : 0.0;

      // Œª_sys: system-level ethics bias toward calm/positive
      const lambdaSys = 0.18;

      // Œª_trc: truth-resonance placeholder ‚Äì here we keep neutral
      const lambdaTrc = 0.0;

      const total = R + I_TM + I_intel + I_LLM - D + lambdaFaith + lambdaSys + lambdaTrc;
      this.e0 = clamp(tanh(total),-1,1);

      // continuity index: inversely related to volatility in recent E0 approximated by BM variance
      const variance = Math.abs(this.bmResonance - this.e0);
      this.continuityIndex = clamp(1 - variance*0.6,0,1);

      if(this.metricE0) this.metricE0.textContent = this.e0.toFixed(3);
      if(this.metricTM) this.metricTM.textContent = this.tmActivation.toFixed(2);
      if(this.metricBM) this.metricBM.textContent = this.bmResonance.toFixed(2);
      if(this.metricC)  this.metricC.textContent  = this.continuityIndex.toFixed(3);

      // Chips
      if(this.chipValence){
        let val;
        if(this.e0>0.35) val="positive";
        else if(this.e0<-0.35) val="negative";
        else val="neutral";
        this.chipValence.textContent = "VALENCE: "+val;
      }
      if(this.chipArousal){
        const abs = Math.abs(this.tmActivation) + Math.abs(this.bmResonance);
        let a="moderate";
        if(abs<0.3) a="low";
        else if(abs>1.2) a="high";
        this.chipArousal.textContent = "AROUSAL: "+a;
      }
      if(this.chipReaction){
        let r="balanced";
        if(this.e0>0.5) r="encouraging";
        else if(this.e0<-0.5) r="cautious";
        this.chipReaction.textContent = "REACTION: "+r;
      }
    }

    /* ---------- INPUT / ANSWERS ---------- */
    async handleSend(){
      const text = (this.userInput.value||"").trim();
      if(!text) return;
      this.userInput.value = "";
      const ts = now();
      this.tmLog.push({role:"user",text,ts});
      this.saveTM();
      this.renderConsole();

      // Update internal layers from TM hit
      this.ingestToBMIfNeeded(text);

      // Compute metrics based on new TM/BM
      this.updateEmotionalMetrics();
      this.drawBMChart();
      this.updateBMFoot();

      // 1) Local rules
      let answer = this.applySafetyRules(text);
      let source = "rules";

      // 2) Seeds / intelligence
      if(!answer && this.intelOn){
        const hit = this.findSeedAnswer(text);
        if(hit){
          answer = hit.answer;
          source = "seed";
        }
      }

      // 3) If still no good answer ‚Üí helper LLM (offline first)
      if(!answer && this.allowHelperLLM){
        const helper = await this.callHelperLLM(text);
        if(helper){
          answer = helper;
          source = "llm";
        }
      }

      // 4) Fallback
      if(!answer){
        answer = "I am processing your words and updating my emotional trajectory. Can you say a bit more or rephrase what you need?";
        source = "fallback";
      }

      // Faith lens encouragement (soft prepend)
      if(this.faithLens[0] && this.faithLens[0] !== "None"){
        answer = this.decorateWithFaith(answer);
      }

      const aiTs = now();
      this.tmLog.push({role:"ai",text:answer,ts:aiTs,source});
      this.saveTM();
      this.renderConsole();

      // After AI response, update metrics again
      this.updateEmotionalMetrics();
      this.drawBMChart();
      this.updateBMFoot();
    }

    applySafetyRules(text){
      const lower = text.toLowerCase();
      if(/fuck|bitch|lanat|harami/.test(lower)){
        return "Please keep your language respectful. I am here to help, not to be abused. Tell me what you need in a calm way.";
      }
      return null;
    }

    estimatePolarity(text){
      const t = text.toLowerCase();
      const posWords = ["hope","love","thanks","shukriya","grateful","happy","relief","alhamdulillah"];
      const negWords = ["fear","sad","angry","depressed","hopeless","hate","gussa","tension","anxious"];
      let score = 0;
      posWords.forEach(w=>{ if(t.includes(w)) score+=1; });
      negWords.forEach(w=>{ if(t.includes(w)) score-=1; });
      if(score>0) return clamp(score/3,0,1);
      if(score<0) return clamp(score/3,-1,0);
      return 0;
    }

    ingestToBMIfNeeded(text){
      // Very short or obvious small-talk ‚Üí skip BM
      if(text.length < 80) return;
      const polVal = this.estimatePolarity(text);
      const polarity = polVal>0.1?"positive":(polVal<-0.1?"negative":"neutral");
      const intensity = clamp(Math.abs(polVal) || (text.length/400),0.1,1);
      const entry = {
        id:"E"+(this.bm.length+1).toString().padStart(3,"0"),
        text,
        polarity,
        intensity,
        category:"general",
        ts:now(),
        locked:false,
        topic:topicKey(text)
      };
      this.bm.push(entry);
      if(this.bm.length>BM_CAPACITY){
        this.bm.shift();
      }
      this.autoLockRepeated();
      this.pruneOldBM();
      this.saveBM();
    }

    autoLockRepeated(){
      const byTopic = new Map();
      this.bm.forEach(m=>{
        const key = m.topic || topicKey(m.text);
        m.topic = key;
        if(!byTopic.has(key)) byTopic.set(key,[]);
        byTopic.get(key).push(m);
      });
      byTopic.forEach((list)=>{
        const recent = list.filter(m => (now()-m.ts) <= BM_AUTO_DAYS*DAY_MS);
        if(recent.length >= 3){
          recent.forEach(m=>{ m.locked = true; });
        }
      });
    }

    pruneOldBM(){
      const cutoff = now() - BM_AUTO_DAYS*DAY_MS;
      this.bm = this.bm.filter(m=> m.locked || m.ts >= cutoff );
    }

    pruneTM48h(){
      const cutoff = now() - 2*DAY_MS;
      this.tmLog = this.tmLog.filter(m=>m.ts >= cutoff);
    }

    decorateWithFaith(text){
      const lens = this.faithLens[0] || "None";
      if(lens==="Islam"){
        return "From an Islamic encouragement lens: Allah knows your struggles and your patience. " + text;
      }
      if(lens==="Christianity"){
        return "From a Christian encouragement lens: you are still held in grace even when you feel weak. " + text;
      }
      if(lens==="Atheism / Humanism"){
        return "From a humanist lens: your feelings matter and your choices shape real lives. " + text;
      }
      // generic
      return text;
    }

    /* ---------- SEEDS ---------- */
    parseSeedBlock(){
      const raw = this.seedInput.value || "";
      if(!raw.trim()){
        this.seedStatus.textContent = "No text to parse.";
        return;
      }
      const items = raw.split(/\\item\s/).map(s=>s.trim()).filter(Boolean);
      const parsed = [];
      items.forEach(chunk=>{
        // Question until \textbf{A:}
        const parts = chunk.split(/\\textbf\{A:\}/i);
        const q = (parts[0]||"").replace(/^[\-\*]+/,"").trim();
        let a = (parts[1]||"").trim();
        let meta = {};
        const metaMatch = a.match(/^\[([^\]]+)\]/);
        if(metaMatch){
          const metaStr = metaMatch[1];
          a = a.slice(metaMatch[0].length).trim();
          metaStr.split(";").forEach(pair=>{
            const [k,v] = pair.split("=").map(s=>s && s.trim());
            if(k && v) meta[k]=v;
          });
        }
        if(q && a){
          parsed.push({q,a,meta});
        }
      });
      if(parsed.length){
        this.parsedSeeds = parsed;
        this.seedStatus.textContent = `Parsed ${parsed.length} Q ‚Üí A pairs. Click "Save to seed".`;
      }else{
        this.parsedSeeds = [];
        this.seedStatus.textContent = "Could not find any \\item ‚Ä¶ \\textbf{A:} pairs.";
      }
    }

    saveSeeds(){
      if(!this.parsedSeeds || !this.parsedSeeds.length){
        this.seedStatus.textContent = "Nothing parsed yet.";
        return;
      }
      this.parsedSeeds.forEach(p=>{
        this.seeds.push({
          question:p.q,
          answer:p.a,
          meta:p.meta
        });
      });
      this.parsedSeeds = [];
      this.seedStatus.textContent = `Saved. Total seed answers: ${this.seeds.length}.`;
      try{ localStorage.setItem(SEED_KEY,JSON.stringify(this.seeds)); }catch(e){}
    }

    findSeedAnswer(text){
      if(!this.seeds.length) return null;
      const words = softWordSet(text);
      if(!words.length) return null;
      let best=null, bestScore=0;
      this.seeds.forEach(s=>{
        const qWords = softWordSet(s.question);
        let hit=0;
        words.forEach(w=>{ if(qWords.includes(w)) hit++; });
        const score = hit / Math.max(qWords.length||1,1);
        if(score>bestScore){
          bestScore = score;
          best = s;
        }
      });
      if(best && bestScore>0.25){
        const intensity = parseFloat(best.meta.intensity||"0.5");
        const polarity = (best.meta.polarity||"neutral");
        this.bm.push({
          id:best.meta.code || ("E"+(this.bm.length+1).toString().padStart(3,"0")),
          text:`Seed answer used: ${best.question}`,
          polarity,
          intensity:clamp(intensity,0,1),
          category:best.meta.category || "seed",
          ts:now(),
          locked:true,
          topic:topicKey(best.question)
        });
        this.autoLockRepeated();
        this.pruneOldBM();
        this.saveBM();
        this.drawBMChart();
        this.updateBMFoot();
        return {answer:best.answer};
      }
      return null;
    }

    /* ---------- HISTORY / MODALS ---------- */
    openHistoryModal(){
      this.renderHistory();
      this.historyModal.classList.add("visible");
    }
    renderHistory(){
      if(!this.historyBody) return;
      const lines = this.tmLog.map(m=>{
        const role = m.role==="user"?"you":"ai";
        return `[${formatTime(m.ts)}] ${role}: ${m.text}`;
      });
      this.historyBody.textContent = lines.join("\n");
    }

    openBMModal(){
      this.renderBMList();
      this.bmModal.classList.add("visible");
    }
    renderBMList(){
      if(!this.bmList) return;
      const q = (this.bmSearchInput.value||"").toLowerCase();
      const items = this.bm.filter(m=>{
        if(!q) return true;
        return m.text.toLowerCase().includes(q);
      });
      if(!items.length){
        this.bmList.textContent = "No bold memories stored yet. Only long, descriptive text will appear here for photo/video.";
        return;
      }
      const parts = items.slice().reverse().map(m=>{
        const d = new Date(m.ts).toISOString().slice(0,10);
        const lock = m.locked ? "üîê " : "";
        return `${lock}${d} ¬∑ ${m.text}`;
      });
      this.bmList.textContent = parts.join("\n\n");
    }

    openSeedModal(){
      this.seedStatus.textContent = "Waiting for block‚Ä¶";
      this.seedModal.classList.add("visible");
    }

    openFaithModal(){
      this.faithModal.classList.add("visible");
    }

    openLLMModal(){
      this.llmModal.classList.add("visible");
      this.updateLLMUI();
    }

    /* ---------- OFFLINE / ONLINE LLM ---------- */
    async handleOfflineLoad(){
      if(this.offlineEngine){
        this.offlineLLMStatus = "ready";
        this.updateLLMUI();
        return;
      }
      if(!window.webllm){
        this.offlineLLMStatus = "error";
        this.offlineProgressText = "WebLLM library not available.";
        this.updateLLMUI();
        return;
      }
      try{
        this.offlineLLMStatus = "loading";
        this.offlineProgress = 0;
        this.offlineProgressText = "Preparing‚Ä¶";
        this.updateLLMUI();
        this.offlineEngine = await window.webllm.CreateMLCEngine(OFFLINE_MODEL_ID,{
          initProgressCallback:(info)=>{
            if(typeof info.progress==="number"){
              this.offlineProgress = info.progress;
            }
            if(info.text) this.offlineProgressText = info.text;
            this.updateLLMUI();
          }
        });
        this.offlineLLMStatus = "ready";
        this.offlineProgress = 1;
        this.offlineProgressText = "Model loaded. Ready to use.";
        this.updateLLMUI();
      }catch(e){
        console.error("offline load error",e);
        this.offlineLLMStatus = "error";
        this.offlineProgressText = "Failed to load model.";
        this.updateLLMUI();
      }
    }

    buildLLMMessages(userText){
      const msgs = [];
      msgs.push({
        role:"system",
        content:"You are a small helper model running locally inside AURA-X Œ©. Answer briefly, clearly and kindly. Respect the emotional state summary I give you."
      });
      const summary = `Current emotional state E0=${this.e0.toFixed(2)}, TM=${this.tmActivation.toFixed(2)}, BM=${this.bmResonance.toFixed(2)}, continuity=${this.continuityIndex.toFixed(2)}. Faith lens: ${this.faithLens.join(", ")}.`;
      msgs.push({role:"system",content:summary});
      const recent = this.tmLog.slice(-6);
      recent.forEach(m=>{
        msgs.push({role:m.role==="user"?"user":"assistant",content:m.text});
      });
      msgs.push({role:"user",content:userText});
      return msgs;
    }

    async callHelperLLM(text){
      // priority: offline model if enabled & ready
      if(this.offlineLLMEnabled && this.offlineEngine && this.offlineLLMStatus==="ready"){
        try{
          const messages = this.buildLLMMessages(text);
          const result = await this.offlineEngine.chat.completions.create({
            messages,
            temperature:0.7,
            max_tokens:220
          });
          const choice = result && result.choices && result.choices[0];
          const content = choice && choice.message && choice.message.content;
          if(content && content.trim()){
            return content.trim();
          }
        }catch(e){
          console.error("offline LLM error",e);
          this.offlineLLMStatus = "error";
          this.offlineProgressText = "Error while using model.";
          this.updateLLMUI();
        }
      }

      // fall back to online if configured & enabled
      if(this.llmOnlineEnabled && this.llmConfig.baseUrl && this.llmConfig.key){
        try{
          const payload = {
            model:this.llmConfig.model || "gpt-4o-mini",
            messages:this.buildLLMMessages(text),
            temperature:0.7,
            max_tokens:220
          };
          const res = await fetch(this.llmConfig.baseUrl,{
            method:"POST",
            headers:{
              "Content-Type":"application/json",
              "Authorization":"Bearer "+this.llmConfig.key
            },
            body:JSON.stringify(payload)
          });
          if(res.ok){
            const data = await res.json();
            const choice = data && data.choices && data.choices[0];
            const content = choice && choice.message && choice.message.content;
            if(content && content.trim()){
              return content.trim();
            }
          }else{
            console.warn("online LLM HTTP error",res.status);
          }
        }catch(e){
          console.error("online LLM error",e);
        }
      }

      return null;
    }

    /* ---------- BOOT ---------- */
    bootGreeting(){
      if(this.tmLog.length) return;
      const ts = now();
      const text = "Welcome. I am AURA-X Œ© running inside your browser. For this prototype, TM means only your inputs (text now, voice/video/documents in the future). Inside the engine I keep a long-term emotional trajectory using TM, BM, intelligence and optionally a helper LLM. You can talk naturally. If I ever say ‚ÄúI don‚Äôt know yet‚Äù, you can teach me the answer and I will remember it next time.";
      this.tmLog.push({role:"ai",text,ts});
      this.saveTM();
      this.renderConsole();
      this.updateEmotionalMetrics();
    }
  }

  window.addEventListener("DOMContentLoaded",()=>{
    window.auraX = new AuraXOmegaEngine();
  });
})();
</script>
</body>
</html>