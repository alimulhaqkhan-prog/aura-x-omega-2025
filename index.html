<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>AURA-X Œ© ‚Äî Offline Emotional Continuity Prototype (Conversation-Window BM)</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:
        radial-gradient(circle at 20% 0%, rgba(30,41,59,.95) 0, transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(14,165,233,.55) 0, transparent 40%),
        linear-gradient(145deg,#020617 0,#020617 40%,#020617 100%);
      color:#e5e7eb;
      min-height:100vh;
      padding:18px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .app{
      width:100%;
      max-width:1100px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    /* Header */
    header.hero{
      border-radius:22px;
      padding:16px 16px;
      background: linear-gradient(135deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 24px 60px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      position:relative;
      overflow:hidden;
    }
    .hero-top{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      flex-wrap:wrap;
    }
    .brand{
      display:flex;flex-direction:column;gap:6px;
    }
    .brand h1{
      font-size:26px;
      letter-spacing:.4px;
      line-height:1.1;
      display:flex;align-items:center;gap:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.35);
    }
    .ethics{
      margin-top:6px;
      font-size:12.5px;
      opacity:.92;
      line-height:1.5;
      max-width:720px;
    }
    .controls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    .small-toggle{
      cursor:pointer;
      border-radius:999px;
      padding:8px 10px;
      font-size:12px;
      color:#e5e7eb;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.35);
      transition:transform .08s.ease, background .2s ease;
      user-select:none;
    }
    .small-toggle:active{transform:scale(.98)}
    .small-toggle.on{
      background:rgba(34,197,94,.18);
      border-color:rgba(34,197,94,.35);
    }
    .small-toggle.danger{
      background:rgba(239,68,68,.15);
      border-color:rgba(239,68,68,.35);
    }

    /* Layout */
    main.layout{
      display:grid;
      grid-template-columns: 1fr 1.2fr;
      gap:14px;
    }
    @media(max-width:980px){
      main.layout{grid-template-columns:1fr}
    }

    /* Cards */
    .card{
      border-radius:22px;
      padding:14px;
      background: linear-gradient(135deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 42px rgba(0,0,0,.30);
      backdrop-filter: blur(10px);
    }
    .card-header{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:8px;
      margin-bottom:10px;
    }
    .card-title{
      display:flex;gap:10px;align-items:center;
      font-size:15px;font-weight:700;
    }
    .emoji{filter: drop-shadow(0 10px 18px rgba(0,0,0,.35))}
    .card-sub{font-size:12px;opacity:.9;line-height:1.5;margin-top:4px}

    /* Metrics */
    .metrics-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .metric{
      border-radius:16px;
      padding:10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(2,6,23,.25);
    }
    .metric-label{font-size:12px;opacity:.92}
    .metric-value{font-size:20px;font-weight:800;margin-top:4px}
    .metric-note{font-size:11px;opacity:.8;margin-top:2px}
    .status-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .tag{
      font-size:11px;
      padding:7px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(2,6,23,.25);
    }

    /* BM Canvas */
    .bm-wrapper{display:flex;flex-direction:column;gap:10px}
    .bm-canvas-shell{
      position:relative;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(2,6,23,.25);
      overflow:hidden;
      height:220px;
    }
    canvas{width:100%;height:100%;display:block}
    .bm-overlay-btn{
      position:absolute;top:10px;
      border-radius:999px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.35);
      color:#e5e7eb;
      cursor:pointer;
      font-size:12px;
      user-select:none;
    }
    .bm-overlay-btn.left{left:10px}
    .bm-overlay-btn.right{right:10px}
    .bm-footer{
      font-size:12px;
      opacity:.9;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }

    /* Console */
    .console-head{
      display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;
      margin-bottom:8px;
    }
    .equation-pill{
      font-size:12px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.25);
      white-space:nowrap;
    }
    .chat{
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(2,6,23,.25);
      padding:10px;
      height:420px;
      overflow:auto;
    }
    .msg{
      display:flex;
      gap:10px;
      margin:10px 0;
      align-items:flex-start;
    }
    .bubble{
      max-width:82%;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.07);
      line-height:1.55;
      white-space:pre-wrap;
      word-break:break-word;
      font-size:13px;
    }
    .msg.user{justify-content:flex-end}
    .msg.user .bubble{
      background:rgba(14,165,233,.16);
      border-color:rgba(14,165,233,.28);
    }
    .meta{
      font-size:10px;opacity:.8;margin-top:6px
    }

    /* Input */
    .input-row{
      margin-top:10px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .input-shell{
      flex:1;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.25);
    }
    textarea{
      flex:1;
      resize:none;
      outline:none;
      border:none;
      background:transparent;
      color:#e5e7eb;
      font-size:13px;
      min-height:22px;
      max-height:110px;
      line-height:1.45;
    }
    .btn{
      cursor:pointer;
      border:none;
      border-radius:999px;
      padding:10px 14px;
      font-weight:700;
      font-size:12px;
      color:#0b1220;
      background:linear-gradient(135deg,#e0f2ff,#93c5fd);
      box-shadow: 0 12px 26px rgba(0,0,0,.25);
      user-select:none;
    }
    .btn:active{transform:scale(.99)}
    .flow{
      margin-top:10px;
      font-size:12px;
      opacity:.9;
      line-height:1.55;
    }

    /* Option panel */
    .option-panel{
      display:none;
      margin-top:10px;
      border-radius:18px;
      padding:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(2,6,23,.25);
    }
    .option-panel.show{display:block}
    .opt-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media(max-width:680px){.opt-grid{grid-template-columns:1fr}}
    .opt{
      border-radius:16px;
      padding:10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
    }
    .opt h3{font-size:13px;margin-bottom:6px}
    .opt p{font-size:12px;opacity:.9;line-height:1.5}
    .mini-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;align-items:center}
    .input-mini{
      width:100%;
      margin-top:8px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.25);
      color:#e5e7eb;
      outline:none;
      font-size:12px;
    }
    select.input-mini{appearance:none}
    .btn-mini{
      cursor:pointer;
      border-radius:12px;
      padding:9px 10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.35);
      color:#e5e7eb;
      font-size:12px;
      user-select:none;
    }
    .btn-mini:active{transform:scale(.99)}
    .btn-mini.btn-danger{
      background:rgba(239,68,68,.15);
      border-color:rgba(239,68,68,.35);
    }
    .btn-mini.btn-ok{
      background:rgba(34,197,94,.16);
      border-color:rgba(34,197,94,.35);
    }

    /* Modals */
    .modal-overlay{
      position:fixed;inset:0;
      display:none;
      background:rgba(0,0,0,.55);
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:50;
    }
    .modal-overlay.show{display:flex}
    .modal-card{
      width:100%;
      max-width:860px;
      border-radius:22px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.92);
      box-shadow: 0 30px 90px rgba(0,0,0,.6);
      overflow:hidden;
    }
    .modal-header{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.10);
      align-items:center;
    }
    .modal-title{font-size:14px;font-weight:800}
    .modal-sub{font-size:12px;opacity:.88;margin-top:3px}
    .modal-close{
      cursor:pointer;
      border-radius:12px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#e5e7eb;
      font-size:12px;
      user-select:none;
    }
    .modal-body{padding:14px}
    .modal-search{
      width:100%;
      padding:11px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#e5e7eb;
      outline:none;
      font-size:12px;
    }
    .list{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height:420px;
      overflow:auto;
      padding-right:4px;
    }
    .item{
      border-radius:16px;
      padding:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
    }
    .item-head{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .item-title{font-size:13px;font-weight:800}
    .item-meta{font-size:11px;opacity:.85}
    .item-text{margin-top:8px;font-size:12.5px;line-height:1.6;opacity:.95;white-space:pre-wrap}
    .chip{
      font-size:10px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.35);
      opacity:.95;
    }

    /* Floating bubble */
    .float-bubble{
      position:fixed;
      right:14px;
      bottom:14px;
      z-index:40;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(2,6,23,.55);
      padding:10px 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
      max-width:320px;
      display:none;
    }
    .float-bubble.show{display:block}
    .float-title{font-size:12px;font-weight:900;margin-bottom:6px}
    .float-text{font-size:12px;opacity:.93;line-height:1.55;white-space:pre-wrap}
    .float-meta{font-size:10px;opacity:.8;margin-top:6px}
  </style>
</head>

<body>
  <div class="app">
    <header class="hero">
      <div class="hero-top">
        <div class="brand">
          <h1>‚ö° AURA-X Œ© <span class="pill">EMOTIONAL CONTINUITY ENGINE ‚Ä¢ OFFLINE</span></h1>
          <div class="ethics">
            Principle: avoid advice that amplifies harm, hatred, or destructive emotions.  
            TM = temporary conversation stream (approx. last 48h).  
            BM = only compressed ‚Äúepisodes/events‚Äù and optional daily digests created from TM √ó BM resonance.
          </div>
        </div>

        <div class="controls">
          <button id="optionsToggle" class="small-toggle">‚öôÔ∏è Options</button>
          <button id="voiceToggle" class="small-toggle on">üîä Voice: ON</button>
          <button id="learningToggle" class="small-toggle on">üìö Learning: ON</button>
          <button id="feedSeedButton" class="small-toggle">üå± Feed-the-Seed</button>
          <button id="bmOpenModal" class="small-toggle">üìÅ BM (Episodes)</button>
          <button id="convOpenModal" class="small-toggle">‚óé TM (History)</button>
        </div>
      </div>

      <div id="optionPanel" class="option-panel">
        <div class="opt-grid">
          <div class="opt">
            <h3>üß† BM: Conversation-window Episodes</h3>
            <p>
              BM stores only meaningful episodes/events extracted from the current conversation window  
              (summaries / ideas / decisions). No time threshold like 20 or 120 minutes ‚Äî only content.
            </p>
            <div class="mini-row">
              <button id="episodeToggle" class="btn-mini btn-ok">Episode Mode: ON</button>
              <button id="finalizeEpisodeBtn" class="btn-mini">Finalize Current Episode (manual)</button>
            </div>
          </div>

          <div class="opt">
            <h3>üìç Location label (optional)</h3>
            <p>You can attach a simple label to BM entries (e.g., ‚ÄúTimergara‚Äù, ‚ÄúCourt‚Äù, ‚ÄúOffice‚Äù). No GPS, only a human label.</p>
            <input id="locationInput" class="input-mini" placeholder="Location label (optional)" />
            <div class="mini-row">
              <button id="saveLocationBtn" class="btn-mini btn-ok">Save Location</button>
              <button id="clearLocationBtn" class="btn-mini btn-danger">Clear</button>
            </div>
          </div>

          <div class="opt">
            <h3>‚ôªÔ∏è TM Decay (~48 hours)</h3>
            <p>TM is just recent conversation. It naturally prunes itself after ~48 hours. BM is long-term compressed memory.</p>
            <div class="mini-row">
              <button id="clear48Btn" class="btn-mini btn-danger">Clear TM (history)</button>
              <button id="clearAllBtn" class="btn-mini btn-danger">Full Reset</button>
            </div>
          </div>

          <div class="opt">
            <h3>üóìÔ∏è Daily Digest (manual)</h3>
            <p>Create a daily digest from BM episodes for a given day ‚Äî you choose when to create it, not time-based.</p>
            <input id="digestDayInput" class="input-mini" placeholder="Day key (YYYY-MM-DD, empty = today)" />
            <div class="mini-row">
              <button id="digestNowBtn" class="btn-mini">Make Daily Digest (manual)</button>
            </div>
          </div>

          <div class="opt">
            <h3>üéõÔ∏è BM Save Strictness</h3>
            <p>Controls how ‚Äúmeaningful‚Äù a window must be before it becomes a BM episode.</p>
            <select id="bmStrictness" class="input-mini">
              <option value="strict">Strict (more selective)</option>
              <option value="normal">Normal</option>
              <option value="loose">Loose (easier to save)</option>
            </select>
            <div class="mini-row">
              <button id="saveStrictBtn" class="btn-mini btn-ok">Save</button>
            </div>
          </div>
        </div>
      </div>
    </header>

    <main class="layout">
      <div class="left-col" style="display:flex;flex-direction:column;gap:14px;">
        <section class="card">
          <div class="card-header">
            <div>
              <div class="card-title"><span class="emoji">üß™</span><span>Emotional Metrics</span></div>
              <div class="card-sub">E‚ÇÄ = tanh((TM √ó (BM + Intel)) ‚àí D + Œª_faith + Œª_sys + Œª_trc) ‚Äî simple demo heuristic.</div>
            </div>
          </div>

          <div class="metrics-grid">
            <div class="metric">
              <div class="metric-label">Emotional state E‚ÇÄ</div>
              <div id="metricE0" class="metric-value">0.00</div>
              <div class="metric-note">range [-1, +1]</div>
            </div>
            <div class="metric">
              <div class="metric-label">TM activation</div>
              <div id="metricTM" class="metric-value">0.00</div>
              <div class="metric-note">recent user input weight</div>
            </div>
            <div class="metric">
              <div class="metric-label">BM resonance</div>
              <div id="metricBM" class="metric-value">0.00</div>
              <div class="metric-note">episode similarity / valence</div>
            </div>
            <div class="metric">
              <div class="metric-label">Continuity index</div>
              <div id="metricCI" class="metric-value">0.80</div>
              <div class="metric-note">trajectory stability</div>
            </div>
          </div>

          <div class="status-row">
            <span id="tagValence" class="tag">VALENCE: neutral</span>
            <span id="tagArousal" class="tag">AROUSAL: medium</span>
            <span id="tagReaction" class="tag">REACTION: balanced</span>
          </div>
        </section>

        <section class="card">
          <div class="card-header">
            <div>
              <div class="card-title"><span class="emoji">üß†</span><span>Bold Memory Layers (240)</span></div>
              <div class="card-sub">BM stores compressed episodes and digests; the spectrum shows positive / neutral / negative bands.</div>
            </div>
          </div>

          <div class="bm-wrapper">
            <div class="bm-canvas-shell" id="bmShell">
              <button class="bm-overlay-btn left" id="bmOpenModal2" title="Browse BM">üìÅ BM</button>
              <button class="bm-overlay-btn right" id="convOpenModal2" title="View TM">‚óé TM</button>
              <canvas id="bmCanvas"></canvas>
            </div>
            <div id="bmStats" class="bm-footer">
              <span>Active layers: 0/240</span>
              <span id="bmCounts">Episodes: 0 ¬∑ Digests: 0</span>
            </div>
          </div>
        </section>
      </div>

      <div class="right-col" style="display:flex;flex-direction:column;gap:14px;">
        <section class="card">
          <div class="console-head">
            <div class="card-title"><span class="emoji">üß¨</span><span>Emotional Continuity Console</span></div>
            <div class="equation-pill">E‚ÇÄ = tanh((TM √ó (BM + Intel)) ‚àí D + Œª‚Ä¶)</div>
          </div>

          <div id="chatContainer" class="chat"></div>

          <div class="input-row">
            <div class="input-shell">
              <textarea id="messageInput" rows="1" placeholder="Type your message‚Ä¶ (Enter = send, Shift+Enter = new line)"></textarea>
            </div>
            <button id="sendButton" class="btn">Send</button>
          </div>

          <div class="flow">
            Flow: TM = conversation history ‚Üí emotional analysis ‚Üí TM √ó BM resonance ‚Üí  
            if a meaningful summary/idea/event emerges from this window ‚Üí compressed BM episode.  
            You can also manually finalize an episode or create a daily digest.
          </div>
        </section>
      </div>
    </main>

    <!-- BM Modal -->
    <div id="bmModal" class="modal-overlay">
      <div class="modal-card">
        <div class="modal-header">
          <div>
            <div class="modal-title">üìÅ Bold Memory ‚Äî Episodes & Daily Digests</div>
            <div class="modal-sub">Only meaningful events are stored here with timestamps, optional location labels, and polarity.</div>
          </div>
          <button class="modal-close" data-close="bmModal">‚úï</button>
        </div>
        <div class="modal-body">
          <input id="bmSearch" class="modal-search" placeholder="Search BM (keyword / location / polarity)..." />
          <div id="bmList" class="list"></div>
        </div>
      </div>
    </div>

    <!-- TM Modal -->
    <div id="convModal" class="modal-overlay">
      <div class="modal-card">
        <div class="modal-header">
          <div>
            <div class="modal-title">‚óé Temporary Memory ‚Äî Conversation History (~48h)</div>
            <div class="modal-sub">Raw conversation stream; this is what collides with BM to generate new stories and episodes.</div>
          </div>
          <button class="modal-close" data-close="convModal">‚úï</button>
        </div>
        <div class="modal-body">
          <div id="convList" class="list"></div>
        </div>
      </div>
    </div>

    <!-- Seed modal -->
    <div id="seedModal" class="modal-overlay">
      <div class="modal-card">
        <div class="modal-header">
          <div>
            <div class="modal-title">üå± Feed the Seed (protected)</div>
            <div class="modal-sub">Paste LaTeX Q‚ÜíA blocks with optional metadata (polarity, category, intensity) to build Intelligence nodes.</div>
          </div>
          <button class="modal-close" data-close="seedModal">‚úï</button>
        </div>
        <div class="modal-body">
          <div id="seedPasswordStage">
            <p style="font-size:12px;opacity:.9;line-height:1.6">
              Protected area. Enter password to unlock. (Demo password: <b>6789</b>)
            </p>
            <input id="seedPasswordInput" type="password" class="modal-search" placeholder="Password (default: 6789)">
            <div id="seedPasswordError" style="display:none;color:#fca5a5;font-size:12px;margin-top:8px;">Incorrect password.</div>
            <button id="seedPasswordBtn" class="btn-mini btn-ok" style="margin-top:10px;">Unlock</button>
          </div>

          <div id="seedBlockStage" style="display:none;">
            <p style="font-size:12px;opacity:.9;line-height:1.6">
              Example format:
              <br><code>\item What is your name? \textbf{A:} I am AURA-X Œ©. [polarity=neutral,category=identity,intensity=0.4]</code>
              <br>Optional global lines:
              <br><code>\textbf{Polarity:} positive</code> etc.
            </p>
            <textarea id="seedBlockInput" class="modal-search" style="min-height:140px;" placeholder="Paste LaTeX block here..."></textarea>
            <div id="seedBlockPreview" style="font-size:12px;opacity:.85;margin-top:10px;">Waiting for block‚Ä¶</div>
            <div class="mini-row" style="margin-top:10px">
              <button id="seedParseBtn" class="btn-mini">Parse</button>
              <button id="seedSaveBtn" class="btn-mini btn-ok" disabled>Save to Seed</button>
              <button id="seedDiscardBtn" class="btn-mini btn-danger">Discard</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Floating reaction bubble -->
    <div id="reactionBubble" class="float-bubble">
      <div class="float-title" id="reactionLabel">REACTION</div>
      <div class="float-text" id="reactionText">‚Ä¶</div>
      <div class="float-meta" id="reactionMeta">‚Ä¶</div>
    </div>

  </div>

<script>
(function(){
  "use strict";

  const STORAGE_KEY = "auraXOmegaState_v7_conv_window";
  const SEED_PASSWORD = "6789";
  const TM_MAX_HOURS = 48;

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function now(){ return new Date(); }
  function iso(dt){ return new Date(dt).toISOString(); }
  function fmt(dt){
    const d = new Date(dt);
    return d.toLocaleString(undefined,{year:"numeric",month:"short",day:"2-digit",hour:"2-digit",minute:"2-digit"});
  }
  function dayKey(dt){
    const d = new Date(dt);
    return d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0")+"-"+String(d.getDate()).padStart(2,"0");
  }
  function makeId(prefix){ return prefix+"_"+Math.random().toString(36).slice(2); }

  // Simple lexicon sentiment (demo)
  const POS = ["good","great","love","happy","hope","excellent","nice","beautiful","thanks","thank","wonderful","perfect","amazing","success","positive"];
  const NEG = ["bad","hate","sad","angry","fear","pain","worried","depressed","negative","problem","wrong","fail","stress","hurt","cry"];

  const GREET = ["hi","hello","hey","salam","salaam","aoa"];

  const CLOSURE = [
    "thanks","thank you","got it","got this","i understand","understand now","ok done","okay done",
    "that‚Äôs all","that's all","end this","finish this","we are done","we're done","move on","new topic","next topic"
  ];

  function analyzeSentiment(text){
    const t = (text||"").toLowerCase();
    let p=0,n=0;
    for(const w of POS){ if(t.includes(w)) p++; }
    for(const w of NEG){ if(t.includes(w)) n++; }

    const score = p - n;
    let polarity = "neutral";
    if(score>0) polarity="positive";
    if(score<0) polarity="negative";

    const intensity = clamp((Math.abs(score) + Math.min(3, (text.length/120))) / 3, 0, 1);
    const arousal = intensity>0.66 ? "high" : (intensity>0.33 ? "medium" : "low");

    let category = "general";
    if(/love/.test(text)) category="love";
    if(/angry|anger/.test(text)) category="anger";
    if(/fear/.test(text)) category="fear";
    if(/sad/.test(text)) category="sadness";
    if(/idea|research|paper|patent|aura|aecn|bm|tm/i.test(text)) category="research";

    return { polarity, valence: clamp(score/5,-1,1), intensity, arousal, category };
  }

  function isGreetingOrTiny(text){
    const s = (text||"").trim();
    if(!s) return true;
    const low = s.toLowerCase();
    if(s.length < 18) return true;
    for(const g of GREET){
      if(low.includes(g)) return true;
    }
    return false;
  }

  function isClosureText(text){
    const low = (text||"").toLowerCase();
    for(const c of CLOSURE){
      if(low.includes(c)) return true;
    }
    return false;
  }

  function normalizeForSearch(s){
    return (s||"").toLowerCase().replace(/\s+/g," ").trim();
  }

  class Engine{
    constructor(){
      this.state = this.loadState() || this.defaultState();
      this.cacheDom();
      this.bind();
      this.pruneTM();
      this.drawBM();
      this.renderAll();
      this.initChatIfEmpty();
      this.startTicker();
    }

    defaultState(){
      return {
        version: 7,
        bmLayers: Array.from({length:240}, ()=>0),
        bmEntries: [],  // {id,type,title,summary,ts,location,polarity,intensity,valence,tags,sourceMsgIds,reason}
        tmHistory: [],  // {id,role,text,ts,sentiment}
        intelNodes: [], // {id,q,a,meta}
        e0: 0,
        lastE0: 0,
        continuityIndex: 0.8,
        voiceOn: true,
        learningMode: true,
        episodeMode: true,
        bmStrictness: "strict",
        locationLabel: "",
        currentEpisode: {
          id: makeId("ep"),
          msgIds: []
        }
      };
    }

    loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch(e){ return null; }
    }
    saveState(){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(this.state)); }catch(e){}
    }

    cacheDom(){
      this.chatContainer = document.getElementById("chatContainer");
      this.messageInput = document.getElementById("messageInput");
      this.sendButton = document.getElementById("sendButton");

      this.metricE0 = document.getElementById("metricE0");
      this.metricTM = document.getElementById("metricTM");
      this.metricBM = document.getElementById("metricBM");
      this.metricCI = document.getElementById("metricCI");
      this.tagValence = document.getElementById("tagValence");
      this.tagArousal = document.getElementById("tagArousal");
      this.tagReaction = document.getElementById("tagReaction");

      this.bmCanvas = document.getElementById("bmCanvas");
      this.bmStats = document.getElementById("bmStats");
      this.bmCounts = document.getElementById("bmCounts");

      this.optionsToggle = document.getElementById("optionsToggle");
      this.optionPanel = document.getElementById("optionPanel");

      this.voiceToggle = document.getElementById("voiceToggle");
      this.learningToggle = document.getElementById("learningToggle");

      this.bmOpenModal = document.getElementById("bmOpenModal");
      this.bmOpenModal2 = document.getElementById("bmOpenModal2");
      this.convOpenModal = document.getElementById("convOpenModal");
      this.convOpenModal2 = document.getElementById("convOpenModal2");

      this.bmModal = document.getElementById("bmModal");
      this.convModal = document.getElementById("convModal");
      this.seedModal = document.getElementById("seedModal");

      this.bmSearch = document.getElementById("bmSearch");
      this.bmList = document.getElementById("bmList");
      this.convList = document.getElementById("convList");

      this.clear48Btn = document.getElementById("clear48Btn");
      this.clearAllBtn = document.getElementById("clearAllBtn");

      this.feedSeedButton = document.getElementById("feedSeedButton");
      this.seedPasswordStage = document.getElementById("seedPasswordStage");
      this.seedBlockStage = document.getElementById("seedBlockStage");
      this.seedPasswordInput = document.getElementById("seedPasswordInput");
      this.seedPasswordError = document.getElementById("seedPasswordError");
      this.seedPasswordBtn = document.getElementById("seedPasswordBtn");
      this.seedBlockInput = document.getElementById("seedBlockInput");
      this.seedBlockPreview = document.getElementById("seedBlockPreview");
      this.seedParseBtn = document.getElementById("seedParseBtn");
      this.seedSaveBtn = document.getElementById("seedSaveBtn");
      this.seedDiscardBtn = document.getElementById("seedDiscardBtn");

      this.episodeToggle = document.getElementById("episodeToggle");
      this.finalizeEpisodeBtn = document.getElementById("finalizeEpisodeBtn");
      this.locationInput = document.getElementById("locationInput");
      this.saveLocationBtn = document.getElementById("saveLocationBtn");
      this.clearLocationBtn = document.getElementById("clearLocationBtn");
      this.bmStrictness = document.getElementById("bmStrictness");
      this.saveStrictBtn = document.getElementById("saveStrictBtn");
      this.digestDayInput = document.getElementById("digestDayInput");
      this.digestNowBtn = document.getElementById("digestNowBtn");

      this.reactionBubble = document.getElementById("reactionBubble");
      this.reactionLabel = document.getElementById("reactionLabel");
      this.reactionText = document.getElementById("reactionText");
      this.reactionMeta = document.getElementById("reactionMeta");
    }

    bind(){
      this.sendButton.addEventListener("click", ()=>this.handleSend());
      this.messageInput.addEventListener("keydown",(e)=>{
        if(e.key==="Enter" && !e.shiftKey){
          e.preventDefault();
          this.handleSend();
        }
      });
      this.messageInput.addEventListener("input", ()=>{
        this.messageInput.style.height="auto";
        this.messageInput.style.height = Math.min(110, this.messageInput.scrollHeight) + "px";
      });

      this.optionsToggle.addEventListener("click", ()=>{
        this.optionPanel.classList.toggle("show");
      });

      this.voiceToggle.addEventListener("click", ()=>{
        this.state.voiceOn = !this.state.voiceOn;
        this.updateToggles();
        this.saveState();
      });

      this.learningToggle.addEventListener("click", ()=>{
        this.state.learningMode = !this.state.learningMode;
        this.updateToggles();
        this.saveState();
      });

      const openBM = ()=>this.openModal(this.bmModal);
      const openTM = ()=>this.openModal(this.convModal);
      this.bmOpenModal.addEventListener("click", openBM);
      this.bmOpenModal2.addEventListener("click", openBM);
      this.convOpenModal.addEventListener("click", openTM);
      this.convOpenModal2.addEventListener("click", openTM);

      document.querySelectorAll("[data-close]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const id = btn.getAttribute("data-close");
          this.closeModal(document.getElementById(id));
        });
      });
      [this.bmModal,this.convModal,this.seedModal].forEach(m=>{
        m.addEventListener("click",(e)=>{
          if(e.target===m) this.closeModal(m);
        });
      });

      this.bmSearch.addEventListener("input", ()=>this.renderBMList());
      this.feedSeedButton.addEventListener("click", ()=>this.openSeedModal());

      this.seedPasswordBtn.addEventListener("click", ()=>this.handleSeedPassword());
      this.seedPasswordInput.addEventListener("keydown",(e)=>{
        if(e.key==="Enter"){ e.preventDefault(); this.handleSeedPassword(); }
      });

      this.seedParseBtn.addEventListener("click", ()=>this.handleSeedParse());
      this.seedSaveBtn.addEventListener("click", ()=>this.handleSeedSave());
      this.seedDiscardBtn.addEventListener("click", ()=>this.handleSeedDiscard());

      this.clear48Btn.addEventListener("click", ()=>{
        this.state.tmHistory = [];
        this.state.currentEpisode.msgIds = [];
        this.saveState();
        this.renderAll();
        this.toastReaction("TM cleared (history).", "TM CLEAR", "neutral", 0.2);
      });

      this.clearAllBtn.addEventListener("click", ()=>{
        localStorage.removeItem(STORAGE_KEY);
        this.state = this.defaultState();
        this.saveState();
        this.drawBM();
        this.renderAll();
        this.toastReaction("All state reset.", "RESET", "neutral", 0.2);
      });

      this.episodeToggle.addEventListener("click", ()=>{
        this.state.episodeMode = !this.state.episodeMode;
        this.updateEpisodeUI();
        this.saveState();
      });

      this.finalizeEpisodeBtn.addEventListener("click", ()=>{
        this.finalizeEpisode("manual");
      });

      this.saveLocationBtn.addEventListener("click", ()=>{
        this.state.locationLabel = (this.locationInput.value||"").trim();
        this.saveState();
        this.toastReaction("Location saved.", this.state.locationLabel || "(empty)", "neutral", 0.2);
      });

      this.clearLocationBtn.addEventListener("click", ()=>{
        this.state.locationLabel = "";
        this.locationInput.value = "";
        this.saveState();
        this.toastReaction("Location cleared.", "Location", "neutral", 0.2);
      });

      this.saveStrictBtn.addEventListener("click", ()=>{
        this.state.bmStrictness = this.bmStrictness.value;
        this.saveState();
        this.toastReaction("BM strictness saved.", this.state.bmStrictness, "neutral", 0.2);
      });

      this.digestNowBtn.addEventListener("click", ()=>{
        const v = (this.digestDayInput.value||"").trim();
        const key = v || dayKey(now());
        this.makeDailyDigest("manual", key);
      });
    }

    startTicker(){
      setInterval(()=>{
        this.pruneTM();
        this.drawBM();
        this.updateMetricsFromState();
        this.saveState();
      }, 60000);
    }

    openModal(m){
      m.classList.add("show");
      if(m===this.bmModal) this.renderBMList();
      if(m===this.convModal) this.renderTMList();
    }
    closeModal(m){ m.classList.remove("show"); }

    updateToggles(){
      this.voiceToggle.classList.toggle("on", !!this.state.voiceOn);
      this.voiceToggle.textContent = this.state.voiceOn ? "üîä Voice: ON" : "üîá Voice: OFF";
      this.learningToggle.classList.toggle("on", !!this.state.learningMode);
      this.learningToggle.textContent = this.state.learningMode ? "üìö Learning: ON" : "üìö Learning: OFF";
    }

    updateEpisodeUI(){
      this.episodeToggle.textContent = this.state.episodeMode ? "Episode Mode: ON" : "Episode Mode: OFF";
      this.episodeToggle.classList.toggle("btn-ok", !!this.state.episodeMode);
      this.episodeToggle.classList.toggle("btn-danger", !this.state.episodeMode);
      this.locationInput.value = this.state.locationLabel || "";
      this.bmStrictness.value = this.state.bmStrictness || "strict";
    }

    initChatIfEmpty(){
      if(this.state.tmHistory.length===0){
        const text =
          "Welcome. I am AURA-X Œ© (offline prototype).\n\n" +
          "TM = temporary conversation history (~48h). BM = compressed episodes and daily digests.\n" +
          "Episodes are not time-based (20 or 120 minutes); they are conversation-window based: " +
          "when a meaningful idea / summary / event emerges, it is compressed and stored in BM.\n\n" +
          "Type naturally. I will monitor the conversation window, and when something meaningful stabilizes, " +
          "I will create a BM episode (or you can press ‚ÄúFinalize Current Episode‚Äù).";
        const sent = analyzeSentiment(text);
        this.addMessage("ai", text, sent);
        this.pushTM("ai", text, sent);
        this.saveState();
      }
    }

    pruneTM(){
      const cutoff = Date.now() - TM_MAX_HOURS*60*60*1000;
      const before = this.state.tmHistory.length;
      this.state.tmHistory = this.state.tmHistory.filter(m => new Date(m.ts).getTime() >= cutoff);
      const after = this.state.tmHistory.length;
      if(after !== before){
        const idSet = new Set(this.state.tmHistory.map(x=>x.id));
        this.state.currentEpisode.msgIds = this.state.currentEpisode.msgIds.filter(id => idSet.has(id));
      }
    }

    pushTM(role,text,sentiment){
      const entry = { id: makeId("tm"), role, text, ts: iso(now()), sentiment: sentiment||null };
      this.state.tmHistory.push(entry);

      if(this.state.episodeMode){
        this.state.currentEpisode.msgIds.push(entry.id);
      }
      return entry;
    }

    addMessage(role,text,sent){
      const wrap = document.createElement("div");
      wrap.className = "msg "+(role==="user"?"user":"ai");
      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.textContent = text;

      const meta = document.createElement("div");
      meta.className = "meta";
      const pol = sent?.polarity ? sent.polarity : "‚Äî";
      const inten = sent?.intensity!=null ? sent.intensity.toFixed(2) : "‚Äî";
      meta.textContent = `‚è± ${fmt(now())}  ‚Ä¢  polarity: ${pol}  ‚Ä¢  intensity: ${inten}`;

      bubble.appendChild(meta);
      wrap.appendChild(bubble);
      this.chatContainer.appendChild(wrap);
      this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
    }

    speakIfOn(text, polarity){
      if(!this.state.voiceOn) return;
      if(!("speechSynthesis" in window)) return;
      try{
        const u = new SpeechSynthesisUtterance(text);
        if(polarity==="negative"){ u.rate = 0.95; u.pitch = 0.9; }
        else if(polarity==="positive"){ u.rate = 1.02; u.pitch = 1.1; }
        else { u.rate = 1.0; u.pitch = 1.0; }
        speechSynthesis.cancel();
        speechSynthesis.speak(u);
      }catch(e){}
    }

    handleSend(){
      const text = (this.messageInput.value||"").trim();
      if(!text) return;

      this.messageInput.value="";
      this.messageInput.style.height="auto";

      const sent = analyzeSentiment(text);
      this.addMessage("user", text, sent);
      this.pushTM("user", text, sent);

      this.updateMetrics(sent);

      const ai = this.reply(text, sent);
      const aiSent = analyzeSentiment(ai);
      this.addMessage("ai", ai, aiSent);
      this.pushTM("ai", aiSent);

      this.speakIfOn(ai, aiSent.polarity);

      // Conversation-window BM logic
      this.maybeFinalizeEpisodeByWindow(text);

      this.saveState();
    }

    reply(userText, sent){
      const match = this.findIntelMatch(userText);
      if(match){
        return match.a;
      }

      const pol = sent.polarity;
      if(pol==="negative"){
        return "I understand this is emotionally heavy. Let's stabilise it. In one or two lines, tell me the core problem and the outcome you want. Then we can compress it into a clean episode.";
      }
      if(pol==="positive"){
        return "Great. If this turns into a clear idea or decision, I will store it as a BM episode so that it becomes part of your long-term continuity.";
      }

      if(/bm|tm|episode|digest|summary/i.test(userText)){
        return "Rule: TM is the raw conversation stream; BM stores only compressed episodes and daily digests. Episodes are triggered by meaningful conversation windows, not by time. You can also press ‚ÄúFinalize Current Episode‚Äù in Options.";
      }

      if(this.state.learningMode && /\?$|Ôºü$/.test(userText)){
        return "I will note this question. If you provide the correct answer in one or two lines, or add it via Feed-the-Seed, I can treat it as an Intelligence rule.";
      }

      return "Okay. Continue the conversation. When a clear idea/summary/decision emerges (or you signal that a topic is finished), I will convert this window into a BM episode.";
    }

    findIntelMatch(text){
      const t = normalizeForSearch(text);
      let best=null, bestScore=0;
      for(const n of this.state.intelNodes){
        const q = normalizeForSearch(n.q);
        if(!q) continue;
        const score = this.similarity(t,q);
        if(score>bestScore){
          bestScore=score;
          best=n;
        }
      }
      return bestScore>=0.72 ? best : null;
    }

    similarity(a,b){
      const A = new Set(a.split(" ").filter(Boolean));
      const B = new Set(b.split(" ").filter(Boolean));
      if(A.size===0 || B.size===0) return 0;
      let inter=0;
      for(const x of A){ if(B.has(x)) inter++; }
      return inter / Math.max(A.size,B.size);
    }

    updateMetrics(sent){
      const recentUser = this.state.tmHistory.filter(m=>m.role==="user").slice(-8);
      const tmAct = recentUser.reduce((s,m)=>s + (m.sentiment?.intensity||0),0) / Math.max(1,recentUser.length);

      const bmRecent = this.state.bmEntries.slice(-10);
      const bmRes = bmRecent.length ? bmRecent.reduce((s,e)=> s + (e.valence||0),0)/bmRecent.length : 0;

      const e0raw = (tmAct * (0.5 + Math.abs(bmRes))) - 0.15 + (sent?.valence||0)*0.25;
      const e0 = Math.tanh(e0raw);

      const delta = Math.abs(e0 - this.state.lastE0);
      const ci = clamp(1 - delta, 0, 1);

      this.state.lastE0 = this.state.e0;
      this.state.e0 = e0;
      this.state.continuityIndex = (this.state.continuityIndex*0.7) + (ci*0.3);

      this.updateMetricsFromState(sent, tmAct, bmRes);
    }

    updateMetricsFromState(sentOverride, tmActOverride, bmResOverride){
      const e0 = this.state.e0 || 0;
      const ci = this.state.continuityIndex || 0.8;

      const tmAct = (tmActOverride!=null) ? tmActOverride : this.estimateTMActivation();
      const bmRes = (bmResOverride!=null) ? bmResOverride : this.estimateBMResonance();

      this.metricE0.textContent = e0.toFixed(2);
      this.metricTM.textContent = tmAct.toFixed(2);
      this.metricBM.textContent = bmRes.toFixed(2);
      this.metricCI.textContent = ci.toFixed(2);

      const sent = sentOverride || analyzeSentiment(this.state.tmHistory.slice(-1)[0]?.text||"");
      const valenceTag = sent.polarity;
      const arousalTag = sent.arousal;
      let reaction = "balanced";
      if(sent.polarity==="negative" && sent.intensity>0.6) reaction="protective";
      if(sent.polarity==="positive" && sent.intensity>0.6) reaction="uplifting";

      this.tagValence.textContent = "VALENCE: "+valenceTag;
      this.tagArousal.textContent = "AROUSAL: "+arousalTag;
      this.tagReaction.textContent = "REACTION: "+reaction;

      this.toastReaction(
        `polarity: ${sent.polarity}\nintensity: ${sent.intensity.toFixed(2)}\ncategory: ${sent.category}`,
        reaction.toUpperCase(),
        sent.polarity,
        sent.intensity
      );
    }

    estimateTMActivation(){
      const recentUser = this.state.tmHistory.filter(m=>m.role==="user").slice(-8);
      return recentUser.reduce((s,m)=>s + (m.sentiment?.intensity||0),0) / Math.max(1,recentUser.length);
    }

    estimateBMResonance(){
      const bmRecent = this.state.bmEntries.slice(-10);
      if(!bmRecent.length) return 0;
      return bmRecent.reduce((s,e)=> s + (e.valence||0),0)/bmRecent.length;
    }

    toastReaction(text,label,polarity,intensity){
      this.reactionLabel.textContent = label;
      this.reactionText.textContent = text;
      this.reactionMeta.textContent = "‚è± "+fmt(now())+"  ‚Ä¢  "+(this.state.locationLabel ? ("üìç "+this.state.locationLabel) : "üìç (no location)");
      this.reactionBubble.classList.add("show");
      clearTimeout(this._rt);
      this._rt = setTimeout(()=>this.reactionBubble.classList.remove("show"), 2400);
    }

    /* ----------------- BM Episode Logic (Conversation-window based) ----------------- */
    bmThresholds(){
      const strict = this.state.bmStrictness || "strict";
      if(strict==="strict"){
        return { minUserMsgs: 4, minChars: 160 };
      }
      if(strict==="normal"){
        return { minUserMsgs: 3, minChars: 120 };
      }
      return { minUserMsgs: 2, minChars: 80 };
    }

    episodeWindowMessages(){
      const ids = new Set(this.state.currentEpisode.msgIds || []);
      return this.state.tmHistory.filter(m=>ids.has(m.id));
    }

    isMeaningfulEpisode(msgs){
      const t = this.bmThresholds();
      const userMsgs = msgs.filter(m=>m.role==="user");
      if(userMsgs.length < t.minUserMsgs) return false;
      const content = userMsgs.map(m=>m.text).join(" ");
      if(content.length < t.minChars) return false;
      const tinyOrGreet = userMsgs.every(m=>isGreetingOrTiny(m.text));
      if(tinyOrGreet) return false;
      return true;
    }

    summarizeEpisode(msgs){
      const userMsgs = msgs.filter(m=>m.role==="user");
      const aiMsgs = msgs.filter(m=>m.role==="ai");

      const contentAll = userMsgs.map(m=>m.text).join(" ");
      const pol = this.aggregatePolarity(msgs);
      const intensity = this.aggregateIntensity(msgs);
      const valence = this.aggregateValence(msgs);

      const key = this.extractKeywords(contentAll).slice(0,6);
      const title = key.length ? ("Episode: "+key.join(", ")) : "Episode: meaningful conversation";

      const lines = userMsgs.slice(-6).map(m=>`‚Ä¢ ${m.text}`).join("\n");
      const aiHint = aiMsgs.length ? ("\n\nAI stance: "+aiMsgs[aiMsgs.length-1].text.slice(0,140)+"‚Ä¶") : "";

      const summary =
        `Compressed summary:\n${lines}\n\nSignals: polarity=${pol}, intensity=${intensity.toFixed(2)}, valence=${valence.toFixed(2)}\n`+
        (this.state.locationLabel ? `Location: ${this.state.locationLabel}\n` : "")+
        (key.length ? `Keywords: ${key.join(", ")}\n` : "")+
        aiHint;

      return { title, summary, polarity: pol, intensity, valence, tags: key };
    }

    aggregatePolarity(msgs){
      let score=0;
      for(const m of msgs){
        const s = m.sentiment;
        if(!s) continue;
        if(s.polarity==="positive") score++;
        if(s.polarity==="negative") score--;
      }
      return score>0 ? "positive" : (score<0 ? "negative" : "neutral");
    }
    aggregateIntensity(msgs){
      const arr = msgs.map(m=>m.sentiment?.intensity).filter(x=>typeof x==="number");
      if(!arr.length) return 0.2;
      return clamp(arr.reduce((a,b)=>a+b,0)/arr.length,0,1);
    }
    aggregateValence(msgs){
      const arr = msgs.map(m=>m.sentiment?.valence).filter(x=>typeof x==="number");
      if(!arr.length) return 0;
      return clamp(arr.reduce((a,b)=>a+b,0)/arr.length,-1,1);
    }

    extractKeywords(text){
      const raw = (text||"").toLowerCase().replace(/[^\p{L}\p{N}\s]/gu," ");
      const stop = new Set(["the","and","or","but","a","an","to","of","in","on","for","is","are","i","you","we","it","this","that","with","from","about","into","as","at","by"]);
      const freq = new Map();
      raw.split(/\s+/).filter(Boolean).forEach(w=>{
        if(w.length<3) return;
        if(stop.has(w)) return;
        freq.set(w,(freq.get(w)||0)+1);
      });
      return [...freq.entries()].sort((a,b)=>b[1]-a[1]).map(x=>x[0]);
    }

    maybeFinalizeEpisodeByWindow(lastUserText){
      if(!this.state.episodeMode) return;

      const msgs = this.episodeWindowMessages();
      if(!msgs.length) return;

      const meaningful = this.isMeaningfulEpisode(msgs);
      const lastUser = [...msgs].filter(m=>m.role==="user").slice(-1)[0];
      const userCount = msgs.filter(m=>m.role==="user").length;

      // 1) if user explicitly closes topic
      if(meaningful && lastUser && isClosureText(lastUserText)){
        this.finalizeEpisode("user-closure");
        return;
      }

      // 2) if episode becomes long and topic shifts strongly, cut window
      if(meaningful && userCount >= (this.bmThresholds().minUserMsgs + 4)){
        const firstUser = msgs.find(m=>m.role==="user");
        if(firstUser && lastUser){
          const s1 = normalizeForSearch(firstUser.text);
          const s2 = normalizeForSearch(lastUser.text);
          const sim = this.similarity(s1,s2);
          if(sim < 0.3){
            this.finalizeEpisode("topic-shift");
            return;
          }
        }
      }

      // 3) if episode is extremely long, force split anyway
      if(userCount >= 16 && meaningful){
        this.finalizeEpisode("long-window");
      }
    }

    finalizeEpisode(reason){
      if(!this.state.episodeMode) return;
      const msgs = this.episodeWindowMessages();
      if(!msgs.length){
        this.state.currentEpisode = { id: makeId("ep"), msgIds: [] };
        this.saveState();
        return;
      }

      if(!this.isMeaningfulEpisode(msgs)){
        this.toastReaction("Current window did not qualify as a meaningful episode (too small / greetings only).", "BM FILTER", "neutral", 0.2);
        this.state.currentEpisode = { id: makeId("ep"), msgIds: [] };
        this.saveState();
        this.drawBM();
        this.renderBMList();
        return;
      }

      const s = this.summarizeEpisode(msgs);
      const entry = {
        id: makeId("bm"),
        type: "episode",
        title: s.title,
        summary: s.summary,
        ts: iso(now()),
        location: this.state.locationLabel || "",
        polarity: s.polarity,
        intensity: s.intensity,
        valence: s.valence,
        tags: s.tags,
        sourceMsgIds: msgs.map(m=>m.id),
        reason
      };
      this.state.bmEntries.push(entry);
      this.applyToBMLayers(entry);

      this.toastReaction("BM episode saved ‚úÖ", entry.title, entry.polarity, entry.intensity);

      this.state.currentEpisode = { id: makeId("ep"), msgIds: [] };
      this.saveState();
      this.drawBM();
      this.renderBMList();
    }

    applyToBMLayers(entry){
      const layers = this.state.bmLayers || [];
      const intensity = clamp(entry.intensity || 0.3, 0, 1);
      const val = clamp((entry.valence || 0), -1, 1);

      let base = 0;
      if(entry.polarity==="positive") base = 40;
      else if(entry.polarity==="negative") base = 160;
      else base = 100;

      const span = Math.floor(20 + intensity*60);
      for(let i=0;i<span;i++){
        const idx = clamp(base + i, 0, layers.length-1);
        layers[idx] = clamp(layers[idx] + (0.15 + intensity*0.4) + Math.abs(val)*0.1, 0, 1);
      }

      for(let i=0;i<layers.length;i++){
        layers[i] = layers[i]*0.995;
      }

      this.state.bmLayers = layers;
    }

    makeDailyDigest(reason, dayKeyTarget){
      const targetDay = dayKeyTarget || dayKey(now());
      const episodes = this.state.bmEntries.filter(e=>{
        if(e.type!=="episode") return false;
        return dayKey(e.ts)===targetDay;
      });

      if(!episodes.length){
        this.toastReaction("No episodes found for that day. Digest not created.", "DIGEST", "neutral", 0.2);
        return;
      }

      // Build fake "sentiment objects" for aggregation
      const pseudoMsgs = episodes.map(e=>({sentiment:{polarity:e.polarity,intensity:e.intensity,valence:e.valence}}));
      const pol = this.aggregatePolarity(pseudoMsgs);
      const intensity = clamp(episodes.reduce((s,e)=>s+(e.intensity||0),0)/episodes.length,0,1);
      const valence = clamp(episodes.reduce((s,e)=>s+(e.valence||0),0)/episodes.length,-1,1);

      const keyFreq = new Map();
      episodes.forEach(e=>{
        (e.tags||[]).forEach(t=>{
          keyFreq.set(t,(keyFreq.get(t)||0)+1);
        });
      });
      const topKeys = [...keyFreq.entries()].sort((a,b)=>b[1]-a[1]).slice(0,8).map(x=>x[0]);

      const summaryLines = episodes.slice(-8).map(e=>{
        const loc = e.location ? `üìç${e.location} ` : "";
        return `‚Ä¢ ${loc}${e.title}  (pol=${e.polarity}, int=${(e.intensity||0).toFixed(2)})`;
      }).join("\n");

      const digestText =
        `Daily Digest ‚Äî ${targetDay}\n\n`+
        `Episodes: ${episodes.length}\n`+
        `Overall: polarity=${pol}, intensity=${intensity.toFixed(2)}, valence=${valence.toFixed(2)}\n`+
        (topKeys.length ? `Top keywords: ${topKeys.join(", ")}\n\n` : "\n")+
        `Events:\n${summaryLines}`;

      const entry = {
        id: makeId("bm"),
        type: "daily",
        title: "Daily Digest ‚Äî "+targetDay,
        summary: digestText,
        ts: iso(now()),
        location: this.state.locationLabel || "",
        polarity: pol,
        intensity,
        valence,
        tags: topKeys,
        sourceMsgIds: episodes.map(e=>e.id),
        reason
      };

      this.state.bmEntries.push(entry);
      this.applyToBMLayers(entry);
      this.toastReaction("Daily Digest saved ‚úÖ", entry.title, entry.polarity, entry.intensity);
      this.saveState();
      this.drawBM();
      this.renderBMList();
    }

    /* ----------------- Rendering ----------------- */
    renderAll(){
      this.updateToggles();
      this.updateEpisodeUI();
      this.renderChatFromTM();
      this.renderBMList();
      this.renderTMList();
      this.updateMetricsFromState();
      this.updateCounts();
    }

    renderChatFromTM(){
      this.chatContainer.innerHTML="";
      const last = this.state.tmHistory.slice(-40);
      for(const m of last){
        const sent = m.sentiment || analyzeSentiment(m.text);
        this.addMessage(m.role==="user"?"user":"ai", m.text, sent);
      }
    }

    renderBMList(){
      const q = normalizeForSearch(this.bmSearch.value||"");
      const entries = [...this.state.bmEntries].reverse().filter(e=>{
        if(!q) return true;
        const blob = normalizeForSearch([e.title,e.summary,e.location,e.polarity,(e.tags||[]).join(" ")].join(" "));
        return blob.includes(q);
      });

      this.bmList.innerHTML="";
      if(!entries.length){
        const d = document.createElement("div");
        d.className="item";
        d.innerHTML = "<div class='item-title'>No BM entries</div><div class='item-text'>Create meaningful episodes via conversation or press ‚ÄúFinalize Current Episode‚Äù.</div>";
        this.bmList.appendChild(d);
        this.updateCounts();
        return;
      }

      for(const e of entries){
        const item = document.createElement("div");
        item.className="item";

        const head = document.createElement("div");
        head.className="item-head";

        const left = document.createElement("div");
        left.innerHTML = `<div class="item-title">${e.type==="daily"?"üóìÔ∏è ":"üìå "}${escapeHtml(e.title)}</div>
                          <div class="item-meta">‚è± ${fmt(e.ts)} ${e.location?(" ‚Ä¢ üìç "+escapeHtml(e.location)):""} ‚Ä¢ polarity: ${e.polarity} ‚Ä¢ intensity: ${(e.intensity||0).toFixed(2)}</div>`;

        const right = document.createElement("div");
        right.style.display="flex";
        right.style.gap="6px";
        right.style.flexWrap="wrap";
        const chips = [];
        chips.push(e.type==="daily" ? "DAILY" : "EPISODE");
        chips.push(e.reason || "");
        for(const c of chips.filter(Boolean)){
          const sp = document.createElement("span");
          sp.className="chip";
          sp.textContent=c;
          right.appendChild(sp);
        }

        head.appendChild(left);
        head.appendChild(right);

        const text = document.createElement("div");
        text.className="item-text";
        text.textContent = e.summary;

        item.appendChild(head);
        item.appendChild(text);
        this.bmList.appendChild(item);
      }
      this.updateCounts();
    }

    renderTMList(){
      this.convList.innerHTML="";
      const items = [...this.state.tmHistory].reverse().slice(0,120);
      if(!items.length){
        const d = document.createElement("div");
        d.className="item";
        d.innerHTML = "<div class='item-title'>TM is empty</div><div class='item-text'>No conversation yet.</div>";
        this.convList.appendChild(d);
        return;
      }
      for(const m of items){
        const item = document.createElement("div");
        item.className="item";
        const pol = m.sentiment?.polarity || "‚Äî";
        const inten = (m.sentiment?.intensity!=null) ? m.sentiment.intensity.toFixed(2) : "‚Äî";
        item.innerHTML = `
          <div class="item-head">
            <div>
              <div class="item-title">${m.role==="user"?"üôÇ User":"ü§ñ AI"}</div>
              <div class="item-meta">‚è± ${fmt(m.ts)} ‚Ä¢ polarity: ${pol} ‚Ä¢ intensity: ${inten}</div>
            </div>
          </div>
          <div class="item-text">${escapeHtml(m.text)}</div>
        `;
        this.convList.appendChild(item);
      }
    }

    updateCounts(){
      const eps = this.state.bmEntries.filter(e=>e.type==="episode").length;
      const dig = this.state.bmEntries.filter(e=>e.type==="daily").length;
      this.bmCounts.textContent = `Episodes: ${eps} ¬∑ Digests: ${dig}`;
    }

    drawBM(){
      const canvas = this.bmCanvas;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(320, Math.floor(rect.width * devicePixelRatio));
      canvas.height = Math.max(220, Math.floor(rect.height * devicePixelRatio));
      const ctx = canvas.getContext("2d");

      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "rgba(2,6,23,0.65)";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      const L = this.state.bmLayers || [];
      const n = 240;
      const pad = 16 * devicePixelRatio;
      const w = canvas.width - pad*2;
      const h = canvas.height - pad*2;
      const barW = w / n;

      for(let i=0;i<n;i++){
        const v = clamp(L[i] || 0, 0, 1);
        const x = pad + i*barW;
        const bh = v * h;
        let r=148,g=163,b=184;
        if(i<80){ r=34; g=197; b=94; }
        else if(i<160){ r=250; g=204; b=21; }
        else { r=239; g=68; b=68; }

        ctx.fillStyle = `rgba(${r},${g},${b},${0.15 + v*0.75})`;
        ctx.fillRect(x, pad + (h-bh), Math.max(1, barW-1), bh);
      }

      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.font = `${12*devicePixelRatio}px system-ui, sans-serif`;
      ctx.fillText("BM 240-layer spectrum (green=positive, yellow=neutral, red=negative)", pad, canvas.height - 10*devicePixelRatio);

      const active = L.filter(v=>(v||0)>0.08).length;
      const eps = this.state.bmEntries.filter(e=>e.type==="episode").length;
      const dig = this.state.bmEntries.filter(e=>e.type==="daily").length;
      this.bmStats.innerHTML = `<span>Active layers: ${active}/240</span><span>Episodes: ${eps} ¬∑ Digests: ${dig}</span>`;
    }

    /* ----------------- Seed Logic ----------------- */
    openSeedModal(){
      this.seedPasswordInput.value="";
      this.seedBlockInput.value="";
      this.seedPasswordError.style.display="none";
      this.seedPasswordStage.style.display="block";
      this.seedBlockStage.style.display="none";
      this.seedSaveBtn.disabled=true;
      this.openModal(this.seedModal);
    }

    handleSeedPassword(){
      const v = (this.seedPasswordInput.value||"").trim();
      if(v !== SEED_PASSWORD){
        this.seedPasswordError.style.display="block";
        return;
      }
      this.seedPasswordError.style.display="none";
      this.seedPasswordStage.style.display="none";
      this.seedBlockStage.style.display="block";
      this.seedBlockPreview.textContent = "Unlocked. Paste LaTeX block and press Parse.";
    }

    handleSeedParse(){
      const raw = (this.seedBlockInput.value||"").trim();
      if(!raw){
        this.seedBlockPreview.textContent="Empty block.";
        this.seedSaveBtn.disabled=true;
        return;
      }
      const parsed = this.parseLatexQA(raw);
      if(!parsed.length){
        this.seedBlockPreview.textContent="No Q‚ÜíA pairs found. Use \\item ... \\textbf{A:} ...";
        this.seedSaveBtn.disabled=true;
        return;
      }
      this._seedParsed = parsed;
      this.seedBlockPreview.textContent = `Parsed ${parsed.length} Q‚ÜíA pairs. Ready to save.`;
      this.seedSaveBtn.disabled=false;
    }

    handleSeedSave(){
      const arr = this._seedParsed || [];
      if(!arr.length) return;
      for(const qa of arr){
        this.state.intelNodes.push({
          id: makeId("intel"),
          q: qa.q,
          a: qa.a,
          meta: qa.meta
        });
      }
      this.saveState();
      this.seedSaveBtn.disabled=true;
      this.seedBlockPreview.textContent = `Saved ‚úÖ (${arr.length} nodes)`;
      this.toastReaction("Seed saved.", `${arr.length} nodes added`, "positive", 0.35);
    }

    handleSeedDiscard(){
      this._seedParsed = [];
      this.seedBlockInput.value="";
      this.seedSaveBtn.disabled=true;
      this.seedBlockPreview.textContent="Discarded.";
    }

    parseLatexQA(raw){
      const lines = raw.split(/\r?\n/);
      let globalMeta = { polarity:null, category:null, intensity:null };
      const out = [];

      const metaFromInline = (s)=>{
        const m = {};
        const bracket = s.match(/\[(.+?)\]/);
        if(bracket){
          const parts = bracket[1].split(",").map(x=>x.trim());
          for(const p of parts){
            const [k,v] = p.split("=").map(x=>x.trim());
            if(!k || v==null) continue;
            const key = k.toLowerCase();
            if(key==="polarity") m.polarity = v.toLowerCase();
            if(key==="category") m.category = v.toLowerCase();
            if(key==="intensity") m.intensity = clamp(parseFloat(v),0,1);
          }
        }
        return m;
      };

      const joined = lines.join("\n");

      const polLine = joined.match(/\\textbf\{Polarity:\}\s*([a-zA-Z]+)/i);
      if(polLine) globalMeta.polarity = polLine[1].toLowerCase();

      const catLine = joined.match(/\\textbf\{Category:\}\s*([a-zA-Z]+)/i);
      if(catLine) globalMeta.category = catLine[1].toLowerCase();

      const intLine = joined.match(/\\textbf\{Intensity:\}\s*([0-9.]+)/i);
      if(intLine) globalMeta.intensity = clamp(parseFloat(intLine[1]),0,1);

      const itemRegex = /\\item\s+([\s\S]*?)(?=(\\item\s+)|$)/g;
      let m;
      while((m = itemRegex.exec(joined))){
        const block = m[1].trim();
        const aSplit = block.split(/\\textbf\{A:\}/i);
        if(aSplit.length<2) continue;
        const qRaw = aSplit[0].replace(/\s+/g," ").trim();
        let aRaw = aSplit.slice(1).join("\\textbf{A:}").trim();

        const inlineMeta = metaFromInline(aRaw) || {};
        aRaw = aRaw.replace(/\[.+?\]/g,"").trim();

        const meta = {
          polarity: inlineMeta.polarity || globalMeta.polarity || null,
          category: inlineMeta.category || globalMeta.category || null,
          intensity: (inlineMeta.intensity!=null) ? inlineMeta.intensity : (globalMeta.intensity!=null ? globalMeta.intensity : null)
        };

        out.push({ q: qRaw, a: aRaw, meta });
      }
      return out;
    }
  }

  function escapeHtml(s){
    return (s||"").replace(/[&<>"']/g,(c)=>({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  const engine = new Engine();
})();
</script>
</body>
</html>