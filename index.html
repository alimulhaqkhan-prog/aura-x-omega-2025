<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AURA-X Œ© ‚Äì Offline Emotional Continuity Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Offline LLM package (WebLLM, for in-browser models) -->
  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";
    window.webllm = webllm;
  </script>

  <style>
    /* RESET & BASICS */
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:
        radial-gradient(circle at 20% 0%, #1e293b 0, transparent 45%),
        radial-gradient(circle at 80% 0%, #0ea5e9 0, transparent 40%),
        linear-gradient(145deg,#020617 0,#020617 40%,#020617 100%);
      color:#e5e7eb;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:16px;
    }
    .app{
      width:100%;
      max-width:1200px;
      background:radial-gradient(circle at top,#0b1220 0,#020617 55%,#020617 100%);
      border-radius:24px;
      box-shadow:0 30px 120px rgba(15,23,42,.8);
      border:1px solid rgba(148,163,184,.25);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      max-height:calc(100vh - 32px);
    }
    header.app-header{
      padding:16px 20px 10px;
      border-bottom:1px solid rgba(148,163,184,.3);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background:linear-gradient(135deg,rgba(15,23,42,.9),rgba(8,47,73,.9));
      position:relative;
      z-index:2;
    }
    .brand-left{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .orbital{
      width:40px;
      height:40px;
      border-radius:999px;
      background:
        radial-gradient(circle at 30% 20%,#facc15 0,#f97316 35%,transparent 55%),
        radial-gradient(circle at 70% 80%,rgba(56,189,248,.9) 0,transparent 60%),
        radial-gradient(circle at 50% 50%,rgba(15,23,42,.9) 0,rgba(15,23,42,0.2) 60%);
      box-shadow:
        0 0 15px rgba(250,204,21,.4),
        0 0 40px rgba(59,130,246,.35);
      position:relative;
      overflow:hidden;
    }
    .orbital::before{
      content:"";
      position:absolute;
      inset:8px;
      border-radius:999px;
      border:1px solid rgba(248,250,252,.5);
      box-shadow:0 0 8px rgba(248,250,252,.45);
    }
    .orbital-orbit{
      position:absolute;
      inset:-4px;
      border-radius:999px;
      border:1px dashed rgba(148,163,184,.55);
      box-shadow:0 0 0 1px rgba(15,23,42,.7);
    }
    .orbital-dot{
      position:absolute;
      width:7px;
      height:7px;
      border-radius:999px;
      background:#e5e7eb;
      top:4px;
      right:7px;
      box-shadow:0 0 10px rgba(248,250,252,.9);
    }
    .brand-text{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .brand-title{
      font-size:0.95rem;
      font-weight:600;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#e5e7eb;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .brand-title span.omega{
      font-size:1.05rem;
      color:#fbbf24;
      text-shadow:0 0 10px rgba(250,204,21,.75);
    }
    .brand-sub{
      font-size:0.75rem;
      color:#9ca3af;
    }
    .ethics-pill{
      font-size:0.7rem;
      color:#facc15;
      border-radius:999px;
      border:1px solid rgba(234,179,8,.6);
      padding:3px 10px;
      background:radial-gradient(circle at top,#1f2937 0,#020617 70%);
      box-shadow:0 0 14px rgba(250,204,21,.35);
      max-width:260px;
      line-height:1.3;
    }
    .top-right-bar{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:4px;
      min-width:210px;
    }
    .mode-badges{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .badge{
      font-size:0.7rem;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      color:#e5e7eb;
      background:linear-gradient(135deg,rgba(15,23,42,.9),rgba(30,64,175,.7));
      display:flex;
      align-items:center;
      gap:4px;
    }
    .badge.offline{
      border-color:rgba(34,197,94,.8);
      background:linear-gradient(135deg,rgba(6,78,59,.9),rgba(22,163,74,.75));
    }
    .badge.smalltalk{
      border-color:rgba(234,179,8,.9);
      background:linear-gradient(135deg,rgba(88,28,135,.9),rgba(234,179,8,.7));
    }
    .badge span.dot{
      width:7px;
      height:7px;
      border-radius:999px;
      background:#22c55e;
      box-shadow:0 0 10px rgba(34,197,94,.9);
    }
    .badge.offline span.dot{background:#4ade80;}
    .badge.smalltalk span.dot{background:#facc15;}
    .llm-status{
      font-size:0.7rem;
      color:#9ca3af;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .llm-status span.icon{
      font-size:0.8rem;
    }

    main.app-main{
      flex:1;
      display:flex;
      flex-direction:row;
      gap:0;
      overflow:hidden;
      position:relative;
    }
    .column{
      flex:1;
      display:flex;
      flex-direction:column;
      border-right:1px solid rgba(15,23,42,.8);
      min-width:0;
    }
    .column:last-child{
      border-right:none;
    }

    .section-header{
      padding:10px 16px 8px;
      border-bottom:1px solid rgba(31,41,55,.9);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background:radial-gradient(circle at top,#111827 0,#020617 100%);
      position:relative;
      z-index:1;
    }
    .section-title{
      font-size:0.8rem;
      text-transform:uppercase;
      letter-spacing:0.09em;
      color:#9ca3af;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .section-title span.icon{
      font-size:0.84rem;
    }
    .section-sub{
      font-size:0.7rem;
      color:#6b7280;
      margin-top:2px;
    }
    .section-actions{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .btn-ghost{
      font-size:0.7rem;
      border-radius:999px;
      padding:3px 8px;
      border:1px solid rgba(55,65,81,.9);
      background:radial-gradient(circle at top,rgba(31,41,55,.8),rgba(15,23,42,1));
      color:#e5e7eb;
      display:flex;
      align-items:center;
      gap:4px;
      cursor:pointer;
    }
    .btn-ghost span.icon{
      font-size:0.8rem;
    }
    .btn-ghost:hover{
      border-color:rgba(59,130,246,.8);
      box-shadow:0 0 0 1px rgba(37,99,235,.4);
    }

    .scroll-area{
      flex:1;
      overflow-y:auto;
      padding:10px 14px 12px;
      position:relative;
    }
    .scroll-inner{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding-bottom:12px;
    }

    .card{
      border-radius:16px;
      border:1px solid rgba(31,41,55,.8);
      background:radial-gradient(circle at top left,rgba(30,64,175,.35),rgba(15,23,42,1) 55%);
      padding:10px 12px;
      box-shadow:0 12px 35px rgba(15,23,42,.85);
      position:relative;
      overflow:hidden;
    }
    .card.light{
      background:radial-gradient(circle at top left,rgba(8,47,73,.4),rgba(15,23,42,1) 60%);
    }
    .card-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:6px;
      margin-bottom:6px;
    }
    .card-title{
      font-size:0.8rem;
      font-weight:500;
      color:#e5e7eb;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .card-title span.icon{
      font-size:0.9rem;
    }
    .card-sub{
      font-size:0.72rem;
      color:#9ca3af;
      margin-top:2px;
    }
    .card-tags{
      display:flex;
      gap:4px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .tag{
      font-size:0.65rem;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(55,65,81,.9);
      color:#9ca3af;
      background:radial-gradient(circle at top,#020617 0,#020617 75%);
    }
    .tag.critical{
      border-color:rgba(248,113,113,.9);
      color:#fecaca;
    }
    .tag.logic{
      border-color:rgba(56,189,248,.9);
      color:#bae6fd;
    }
    .tag.faith{
      border-color:rgba(250,204,21,.9);
      color:#fef9c3;
    }

    .pill-row{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:4px;
    }
    .pill{
      font-size:0.68rem;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid rgba(51,65,85,1);
      background:radial-gradient(circle at top,#020617 0,#020617 70%);
      color:#9ca3af;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .pill span.dot{
      width:6px;
      height:6px;
      border-radius:999px;
      background:#22c55e;
      box-shadow:0 0 6px rgba(34,197,94,.8);
    }
    .pill.tm span.dot{background:#38bdf8;}
    .pill.bm span.dot{background:#a855f7;}
    .pill.faith span.dot{background:#facc15;}
    .pill.sys span.dot{background:#22c55e;}
    .pill.trc span.dot{background:#f97316;}

    .metrics-grid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:8px;
      margin-top:4px;
    }
    .metric{
      border-radius:12px;
      padding:6px 8px;
      border:1px solid rgba(31,41,55,.9);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .metric-label{
      font-size:0.7rem;
      color:#9ca3af;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .metric-value{
      font-family:"JetBrains Mono","SF Mono",ui-monospace,monospace;
      font-size:0.95rem;
      font-weight:500;
      color:#e5e7eb;
    }
    .metric-note{
      font-size:0.65rem;
      color:#6b7280;
    }
    .meter{
      width:100%;
      height:6px;
      border-radius:999px;
      background:rgba(15,23,42,1);
      overflow:hidden;
      margin-top:2px;
    }
    .meter-fill{
      height:100%;
      width:0%;
      border-radius:999px;
      background:linear-gradient(90deg,#ef4444,#f97316,#22c55e);
      box-shadow:0 0 8px rgba(34,197,94,.7);
      transition:width .35s ease-out;
    }

    .tm-bm-grid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:8px;
      margin-top:4px;
    }
    .log-box{
      border-radius:12px;
      border:1px solid rgba(31,41,55,.9);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      padding:6px 8px;
      font-size:0.7rem;
    }
    .log-title{
      font-size:0.7rem;
      color:#9ca3af;
      margin-bottom:2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:6px;
    }
    .log-body{
      max-height:140px;
      overflow-y:auto;
      padding-right:2px;
    }
    .log-entry{
      margin-bottom:4px;
      padding-bottom:4px;
      border-bottom:1px dashed rgba(30,64,175,.5);
    }
    .log-entry:last-child{
      border-bottom:none;
      margin-bottom:0;
      padding-bottom:0;
    }
    .log-entry .who{
      font-size:0.65rem;
      color:#6b7280;
    }
    .log-entry .txt{
      font-size:0.7rem;
      color:#e5e7eb;
      margin-top:1px;
    }
    .log-entry .emo{
      font-size:0.62rem;
      color:#9ca3af;
      margin-top:1px;
    }

    .bm-badges{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      margin-top:4px;
    }
    .bm-tag{
      font-size:0.65rem;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(55,65,81,1);
      color:#e5e7eb;
      background:radial-gradient(circle at top,#0b1120,#020617 75%);
    }

    .bm-list{
      margin-top:4px;
      max-height:260px;
      overflow-y:auto;
      padding-right:2px;
      font-size:0.7rem;
    }
    .bm-item{
      border-radius:10px;
      border:1px solid rgba(31,41,55,.9);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      padding:6px 7px;
      margin-bottom:4px;
    }
    .bm-item-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:4px;
      margin-bottom:2px;
    }
    .bm-item-title{
      font-size:0.7rem;
      color:#e5e7eb;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .bm-item-meta{
      font-size:0.65rem;
      color:#6b7280;
      display:flex;
      gap:4px;
      align-items:center;
    }
    .bm-item-body{
      font-size:0.7rem;
      color:#9ca3af;
      margin-top:2px;
    }
    .bm-item-actions{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      margin-top:4px;
    }
    .bm-item-actions button{
      font-size:0.65rem;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(55,65,81,.9);
      background:radial-gradient(circle at top,#020617 0,#020617 75%);
      color:#e5e7eb;
      cursor:pointer;
    }
    .bm-item-actions button:hover{
      border-color:rgba(59,130,246,.9);
    }

    .bm-search-input{
      width:100%;
      border-radius:999px;
      border:1px solid rgba(55,65,81,1);
      background:radial-gradient(circle at top,#020617 0,#020617 85%);
      color:#e5e7eb;
      padding:4px 8px;
      font-size:0.7rem;
      outline:none;
    }
    .bm-search-input::placeholder{
      color:#4b5563;
    }

    .conversation-pane{
      display:flex;
      flex-direction:column;
      gap:8px;
      height:100%;
    }
    .conversation-top{
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1;
      min-height:0;
    }
    .equation-box{
      border-radius:16px;
      border:1px solid rgba(31,41,55,.9);
      background:
        radial-gradient(circle at left,#0ea5e9 0,transparent 35%),
        radial-gradient(circle at right,#22c55e 0,transparent 35%),
        radial-gradient(circle at top,#020617 0,#020617 80%);
      padding:10px 11px;
      position:relative;
      overflow:hidden;
    }
    .equation-header{
      font-size:0.78rem;
      color:#9ca3af;
      text-transform:uppercase;
      letter-spacing:0.08em;
      margin-bottom:3px;
    }
    .equation-divider{
      height:1px;
      background:linear-gradient(90deg,transparent,#64748b,transparent);
      margin:3px 0 6px;
    }
    .equation-main{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .equation-row{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:4px;
      font-family:"JetBrains Mono","SF Mono",ui-monospace,monospace;
      font-size:0.8rem;
      color:#e5e7eb;
    }
    .equation-symbol{
      color:#facc15;
    }
    .equation-span{
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(55,65,81,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      color:#e5e7eb;
    }
    .equation-span.light{
      background:radial-gradient(circle at top,#020617 0,#020617 70%);
      color:#e5e7eb;
    }
    .equation-note{
      font-size:0.68rem;
      color:#9ca3af;
    }
    .equation-badges{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      margin-top:4px;
    }
    .equation-badge{
      font-size:0.65rem;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(55,65,81,.9);
      color:#e5e7eb;
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      display:flex;
      align-items:center;
      gap:4px;
    }
    .equation-badge span.dot{
      width:6px;
      height:6px;
      border-radius:999px;
      background:#facc15;
      box-shadow:0 0 7px rgba(250,204,21,.8);
    }

    .answer-box{
      border-radius:16px;
      border:1px solid rgba(31,41,55,.9);
      background:
        radial-gradient(circle at top,#020617 0,#020617 80%),
        radial-gradient(circle at bottom,#020617 0,#020617 80%);
      padding:10px 11px;
      display:flex;
      flex-direction:column;
      gap:6px;
      min-height:180px;
      position:relative;
      overflow:hidden;
    }
    .chat-container{
      max-height:240px;
      overflow-y:auto;
      padding-right:4px;
      font-size:0.78rem;
    }
    .message{
      margin-bottom:6px;
      display:flex;
      gap:6px;
    }
    .message.user .bubble{
      margin-left:auto;
      background:linear-gradient(135deg,#1d4ed8,#0ea5e9);
    }
    .message.ai .bubble{
      margin-right:auto;
      background:radial-gradient(circle at top left,#111827 0,#020617 80%);
      border:1px solid rgba(31,41,55,.9);
    }
    .avatar{
      width:20px;
      height:20px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:0.7rem;
      background:radial-gradient(circle at top,#0ea5e9 0,#1d4ed8 60%);
      color:#e5e7eb;
      box-shadow:0 0 8px rgba(59,130,246,.8);
    }
    .avatar.ai{
      background:radial-gradient(circle at top,#eab308 0,#f97316 60%);
      box-shadow:0 0 8px rgba(250,204,21,.7);
    }
    .bubble{
      max-width:82%;
      padding:6px 8px;
      border-radius:12px;
      font-size:0.78rem;
      line-height:1.4;
      color:#e5e7eb;
      position:relative;
      white-space:pre-wrap;
    }
    .bubble.meta{
      font-size:0.7rem;
      color:#9ca3af;
      background:none;
      border:none;
      max-width:100%;
      padding:0;
    }
    .meta-line{
      font-size:0.68rem;
      color:#6b7280;
    }
    .typing{
      font-size:0.72rem;
      color:#9ca3af;
      font-style:italic;
    }

    .input-footer{
      border-top:1px solid rgba(15,23,42,1);
      padding:8px 12px 10px;
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .tm-formula-row{
      display:flex;
      justify-content:center;
      margin-bottom:2px;
    }
    .tm-formula-pill{
      font-family:"JetBrains Mono","SF Mono",ui-monospace,monospace;
      font-size:0.75rem;
      color:#e5e7eb;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(55,65,81,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      text-align:center;
      white-space:nowrap;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .input-row{
      display:flex;
      align-items:flex-end;
      gap:6px;
    }
    .input-shell{
      flex:1;
      border-radius:999px;
      border:1px solid rgba(55,65,81,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      display:flex;
      align-items:center;
      padding:3px 4px 3px 10px;
      gap:4px;
    }
    .message-input{
      flex:1;
      background:transparent;
      border:none;
      resize:none;
      font-size:0.8rem;
      color:#e5e7eb;
      padding:4px 0;
      min-height:22px;
      max-height:70px;
      outline:none;
    }
    .message-input::placeholder{
      color:#4b5563;
    }
    .send-button{
      border-radius:999px;
      border:none;
      padding:5px 12px;
      font-size:0.8rem;
      color:#020617;
      background:linear-gradient(135deg,#fbbf24,#22c55e);
      box-shadow:0 0 10px rgba(250,204,21,.7);
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .send-button::before{
      content:"‚û§";
      font-size:0.75rem;
    }
    .send-button:hover{
      filter:brightness(1.1);
    }
    .flow-caption{
      font-size:0.68rem;
      color:#6b7280;
      text-align:center;
    }

    .modal-overlay{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.92);
      backdrop-filter:blur(12px);
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:0;
      pointer-events:none;
      transition:opacity .2s ease-out;
      z-index:40;
    }
    .modal-overlay.visible{
      opacity:1;
      pointer-events:auto;
    }
    .modal-card{
      width:100%;
      max-width:640px;
      max-height:78vh;
      background:radial-gradient(circle at top,#020617 0,#020617 85%);
      border-radius:20px;
      border:1px solid rgba(55,65,81,1);
      box-shadow:0 24px 80px rgba(0,0,0,.9);
      padding:12px 14px 14px;
      display:flex;
      flex-direction:column;
      gap:8px;
      position:relative;
    }
    .modal-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .modal-title{
      font-size:0.85rem;
      font-weight:500;
      color:#e5e7eb;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .modal-title span.icon{
      font-size:0.9rem;
    }
    .modal-sub{
      font-size:0.7rem;
      color:#9ca3af;
      margin-top:2px;
    }
    .modal-close{
      border-radius:999px;
      border:1px solid rgba(55,65,81,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      color:#e5e7eb;
      font-size:0.75rem;
      padding:3px 8px;
      cursor:pointer;
    }
    .modal-body{
      flex:1;
      min-height:0;
      padding-top:4px;
      display:flex;
      flex-direction:column;
      gap:7px;
    }
    .modal-section{
      border-radius:12px;
      border:1px solid rgba(31,41,55,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      padding:6px 8px;
      font-size:0.72rem;
    }
    .modal-section-title{
      font-size:0.72rem;
      color:#9ca3af;
      margin-bottom:3px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:6px;
    }
    .modal-section-body{
      font-size:0.72rem;
      color:#e5e7eb;
    }
    .modal-footer{
      margin-top:4px;
      display:flex;
      justify-content:flex-end;
      gap:6px;
    }
    .modal-search{
      width:100%;
      border-radius:10px;
      border:1px solid rgba(55,65,81,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      color:#e5e7eb;
      padding:4px 7px;
      font-size:0.72rem;
      outline:none;
    }
    .modal-search::placeholder{
      color:#4b5563;
    }

    .tm-badge{
      font-size:0.62rem;
      padding:1px 5px;
      border-radius:999px;
      border:1px solid rgba(37,99,235,1);
      color:#bfdbfe;
    }
    .bm-badge{
      font-size:0.62rem;
      padding:1px 5px;
      border-radius:999px;
      border:1px solid rgba(147,51,234,1);
      color:#e9d5ff;
    }

    .time-bubble{
      position:absolute;
      top:8px;
      right:12px;
      font-size:0.68rem;
      color:#9ca3af;
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      border-radius:999px;
      padding:2px 7px;
      border:1px solid rgba(55,65,81,1);
    }

    .intel-list{
      max-height:260px;
      overflow-y:auto;
      padding-right:2px;
      font-size:0.72rem;
      margin-top:4px;
    }
    .intel-item{
      border-radius:10px;
      border:1px solid rgba(31,41,55,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      padding:6px 7px;
      margin-bottom:4px;
    }
    .intel-q{
      font-size:0.72rem;
      color:#e5e7eb;
    }
    .intel-a{
      font-size:0.72rem;
      color:#9ca3af;
      margin-top:2px;
    }
    .intel-meta{
      font-size:0.65rem;
      color:#6b7280;
      margin-top:2px;
      display:flex;
      flex-wrap:wrap;
      gap:4px;
    }
    .intel-actions{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      margin-top:4px;
    }
    .intel-actions button{
      font-size:0.65rem;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(55,65,81,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      color:#e5e7eb;
      cursor:pointer;
    }
    .intel-actions button:hover{
      border-color:rgba(59,130,246,.9);
    }

    .badge-ep{
      font-size:0.62rem;
      padding:1px 4px;
      border-radius:999px;
      border:1px solid rgba(56,189,248,1);
      color:#bae6fd;
    }
    .badge-lock{
      font-size:0.62rem;
      padding:1px 4px;
      border-radius:999px;
      border:1px solid rgba(248,250,252,.6);
      color:#e5e7eb;
    }

    .slider-row{
      display:flex;
      align-items:center;
      gap:6px;
      margin-top:4px;
    }
    .slider-row label{
      font-size:0.7rem;
      color:#9ca3af;
      min-width:70px;
    }
    .slider-row input[type=range]{
      flex:1;
    }
    .slider-value{
      font-size:0.7rem;
      color:#e5e7eb;
      min-width:32px;
      text-align:right;
      font-family:"JetBrains Mono","SF Mono",ui-monospace,monospace;
    }

    .llm-config-row{
      display:grid;
      grid-template-columns:1.1fr 0.9fr;
      gap:6px;
      margin-top:4px;
    }
    .llm-config-row label{
      font-size:0.7rem;
      color:#9ca3af;
    }
    .llm-config-row input{
      width:100%;
      border-radius:8px;
      border:1px solid rgba(55,65,81,1);
      background:radial-gradient(circle at top,#020617 0,#020617 80%);
      color:#e5e7eb;
      padding:3px 6px;
      font-size:0.7rem;
      outline:none;
    }
    .llm-config-row input::placeholder{
      color:#4b5563;
    }
    .llm-checkbox-row{
      display:flex;
      align-items:center;
      gap:5px;
      font-size:0.7rem;
      color:#9ca3af;
      margin-top:4px;
    }
    .llm-checkbox-row input{
      transform:scale(0.9);
    }
    .llm-status-text{
      font-size:0.68rem;
      color:#6b7280;
      margin-top:4px;
    }

    @media (max-width:960px){
      main.app-main{
        flex-direction:column;
      }
      .column{
        border-right:none;
        border-bottom:1px solid rgba(15,23,42,1);
      }
      .column:last-child{
        border-bottom:none;
      }
    }
    @media (max-width:720px){
      header.app-header{
        flex-direction:column;
        align-items:flex-start;
      }
      .top-right-bar{
        align-items:flex-start;
      }
      .app{
        max-height:none;
      }
      .chat-container{
        max-height:200px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="app-header">
      <div class="brand-left">
        <div class="orbital">
          <div class="orbital-orbit"></div>
          <div class="orbital-dot"></div>
        </div>
        <div class="brand-text">
          <div class="brand-title">
            <span class="omega">AURA-X Œ©</span>
            <span>EMOTIONAL CONTINUITY ENGINE</span>
          </div>
          <div class="brand-sub">
            Parallel TM‚ÄìBM resonance ¬∑ ethical trajectory ¬∑ offline + online LLM blend
          </div>
        </div>
      </div>
      <div class="top-right-bar">
        <div class="mode-badges">
          <div class="badge">
            <span class="dot"></span>
            <span>Continuity Reflex Model (CRM)</span>
          </div>
          <div class="badge offline">
            <span class="dot"></span>
            <span>Offline helper LLM</span>
          </div>
          <div class="badge smalltalk">
            <span class="dot"></span>
            <span>Small-talk filter</span>
          </div>
        </div>
        <div class="ethics-pill">
          Avoid actions that create negative emotions in you or others‚Äîgently prefer steps that increase shared, honest wellbeing.
        </div>
        <div class="llm-status">
          <span class="icon">‚öôÔ∏è</span>
          <span id="llmStatusText">LLM: offline helper only ‚Ä¢ API not configured</span>
        </div>
      </div>
    </header>

    <main class="app-main">
      <section class="column">
        <div class="section-header">
          <div>
            <div class="section-title">
              <span class="icon">üì°</span>
              <span>Internal state & metrics</span>
            </div>
            <div class="section-sub">
              TM ‚Üî BM resonance ¬∑ continuity ¬∑ Œª coefficients
            </div>
          </div>
          <div class="section-actions">
            <button id="bmOpenModal" class="btn-ghost">
              <span class="icon">üß†</span>
              <span>Open BM memories</span>
            </button>
            <button id="intelOpenModal" class="btn-ghost">
              <span class="icon">üìö</span>
              <span>Seed & intelligence</span>
            </button>
          </div>
        </div>
        <div class="scroll-area">
          <div class="scroll-inner">
            <div class="card light">
              <div class="card-header">
                <div>
                  <div class="card-title">
                    <span class="icon">üß™</span>
                    <span>Emotional metrics</span>
                  </div>
                  <div class="card-sub">
                    Internal state based on TM (your inputs) colliding with BM, Intelligence and optional helper LLM.
                  </div>
                </div>
              </div>
              <div class="metrics-grid">
                <div class="metric">
                  <div class="metric-label">
                    <span>Emotional state E‚ÇÄ</span>
                    <span id="metricE0Label" class="metric-note"></span>
                  </div>
                  <div id="metricE0" class="metric-value">0.00</div>
                  <div class="meter">
                    <div id="meterE0" class="meter-fill"></div>
                  </div>
                  <div class="metric-note">tanh-based, range [-1, +1]</div>
                </div>
                <div class="metric">
                  <div class="metric-label">
                    <span>TM activation (user only)</span>
                    <span id="metricTMLabel" class="metric-note"></span>
                  </div>
                  <div id="metricTM" class="metric-value">0.00</div>
                  <div class="meter">
                    <div id="meterTM" class="meter-fill"></div>
                  </div>
                  <div class="metric-note">recent polarity & intensity of your inputs</div>
                </div>
                <div class="metric">
                  <div class="metric-label">
                    <span>Continuity index</span>
                    <span id="metricContLabel" class="metric-note"></span>
                  </div>
                  <div id="metricCont" class="metric-value">0.00</div>
                  <div class="meter">
                    <div id="meterCont" class="meter-fill"></div>
                  </div>
                  <div class="metric-note">smooth emotional trajectory vs abrupt swings</div>
                </div>
                <div class="metric">
                  <div class="metric-label">
                    <span>BM resonance gain</span>
                    <span id="metricBMLabel" class="metric-note"></span>
                  </div>
                  <div id="metricBM" class="metric-value">0.00</div>
                  <div class="meter">
                    <div id="meterBM" class="meter-fill"></div>
                  </div>
                  <div class="metric-note">how strongly BM stories echo current TM</div>
                </div>
              </div>
              <div class="pill-row" style="margin-top:6px;">
                <div class="pill tm">
                  <span class="dot"></span>
                  <span>TM = fresh user input</span>
                </div>
                <div class="pill bm">
                  <span class="dot"></span>
                  <span>BM = distilled emotional episodes</span>
                </div>
                <div class="pill faith">
                  <span class="dot"></span>
                  <span>Œª_faith = belief/meaning lens</span>
                </div>
                <div class="pill sys">
                  <span class="dot"></span>
                  <span>Œª_sys = system-structure & ethics</span>
                </div>
                <div class="pill trc">
                  <span class="dot"></span>
                  <span>Œª_trc = truth-resonance correction</span>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">
                <div>
                  <div class="card-title">
                    <span class="icon">üîÑ</span>
                    <span>TM & BM traffic</span>
                  </div>
                  <div class="card-sub">
                    Short-term TM stream on the left; compressed BM episodes on the right.
                  </div>
                </div>
              </div>
              <div class="tm-bm-grid">
                <div class="log-box">
                  <div class="log-title">
                    <span>TM stream (conversation history)</span>
                    <span class="tm-badge">TM only</span>
                  </div>
                  <div id="tmLog" class="log-body"></div>
                </div>
                <div class="log-box">
                  <div class="log-title">
                    <span>BM episodes (distilled story)</span>
                    <span class="bm-badge">BM</span>
                  </div>
                  <div id="bmEpisodeLog" class="log-body"></div>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">
                <div>
                  <div class="card-title">
                    <span class="icon">üìú</span>
                    <span>Bold Memory registry</span>
                  </div>
                  <div class="card-sub">
                    Stored episodes that survived decay and repetition filters.
                  </div>
                </div>
                <div class="card-tags">
                  <span class="tag">Decay engine D</span>
                  <span class="tag">Continuity reflex</span>
                </div>
              </div>
              <input id="bmSearch" class="bm-search-input" placeholder="Search BM by keyword, tag or emotion‚Ä¶" />
              <div id="bmList" class="bm-list"></div>
            </div>
          </div>
        </div>
      </section>

      <section class="column">
        <div class="section-header">
          <div>
            <div class="section-title">
              <span class="icon">üí¨</span>
              <span>Conversation & AURA-X Œ© response</span>
            </div>
            <div class="section-sub">
              TM = your messages ¬∑ BM = distilled story ¬∑ helper LLM = optional
            </div>
          </div>
          <div class="section-actions">
            <button id="convOpenModal" class="btn-ghost">
              <span class="icon">üß¨</span>
              <span>Conversation DNA</span>
            </button>
            <button id="faithOpenModal" class="btn-ghost">
              <span class="icon">üïäÔ∏è</span>
              <span>Faith lens</span>
            </button>
            <button id="seedOpenModal" class="btn-ghost">
              <span class="icon">üß©</span>
              <span>Feed the seed</span>
            </button>
            <button id="llmOpenModal" class="btn-ghost">
              <span class="icon">ü§ñ</span>
              <span>LLM settings</span>
            </button>
          </div>
        </div>
        <div class="scroll-area">
          <div class="scroll-inner conversation-pane">
            <div class="conversation-top">
              <div class="equation-box">
                <div class="equation-header">Grand Emotional Continuity Equation</div>
                <div class="equation-divider"></div>
                <div class="equation-main">
                  <div class="equation-row">
                    <span class="equation-symbol">E‚ÇÄ =</span>
                    <span class="equation-span">tanh( R(TM, BM) ‚àí D + Œª_faith + Œª_sys + Œª_trc )</span>
                  </div>
                  <div class="equation-note">
                    E‚ÇÄ is the current emotional state. R(TM,BM) is resonance between your fresh input and stored episodes. D is decay.
                    Œª_faith, Œª_sys and Œª_trc adjust the trajectory using faith/belief, system-ethics and truth-resonance.
                  </div>
                  <div class="equation-badges">
                    <div class="equation-badge">
                      <span class="dot"></span>
                      <span>R(TM,BM): match between recent TM and BM story</span>
                    </div>
                    <div class="equation-badge">
                      <span class="dot"></span>
                      <span>D: time-decay + emotional fatigue</span>
                    </div>
                    <div class="equation-badge">
                      <span class="dot"></span>
                      <span>Œª_faith, Œª_sys, Œª_trc: correcting lenses</span>
                    </div>
                  </div>
                </div>
              </div>

              <div class="answer-box">
                <div class="equation-header">AURA-X Œ© CONVERSATION</div>
                <div class="equation-divider"></div>
                <div id="chatTimeBubble" class="time-bubble" style="display:none;"></div>
                <div id="chatContainer" class="chat-container"></div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="input-footer">
      <div class="tm-formula-row">
        <div class="tm-formula-pill">E‚ÇÄ = tanh( R(TM, BM) ‚àí D + Œª_faith + Œª_sys + Œª_trc )</div>
      </div>
      <div class="input-row">
        <div class="input-shell">
          <textarea id="messageInput" class="message-input" rows="1"
            placeholder="Talk to AURA-X Œ©‚Ä¶ (TM = your inputs only ‚Äì text now, voice/video/docs later)"></textarea>
          <button id="sendButton" class="send-button">Send</button>
        </div>
      </div>
      <div class="flow-caption">
        Pipeline: TM (your inputs) ‚Üí optional helper LLM ‚Üí resonance with BM ‚Üí continuity reflex ‚Üí E‚ÇÄ.
      </div>
    </footer>
  </div>

  <!-- BM MODAL -->
  <div id="bmModal" class="modal-overlay">
    <div class="modal-card">
      <div class="modal-header">
        <div>
          <div class="modal-title">
            <span class="icon">üß†</span>
            <span>Bold Memory (BM) episodes</span>
          </div>
          <div class="modal-sub">
            These are distilled emotional ‚Äúepisodes‚Äù that survived decay and repetition filters.
          </div>
        </div>
        <button class="modal-close" data-close="bmModal">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-section">
          <div class="modal-section-title">
            <span>Episodes list</span>
            <span class="badge-ep">TM√óBM continuity</span>
          </div>
          <div class="modal-section-body">
            <div id="bmModalList" class="intel-list"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-close" data-close="bmModal">Done</button>
      </div>
    </div>
  </div>

  <!-- CONVERSATION DNA MODAL -->
  <div id="convModal" class="modal-overlay">
    <div class="modal-card">
      <div class="modal-header">
        <div>
          <div class="modal-title">
            <span class="icon">üß¨</span>
            <span>Conversation DNA & continuity</span>
          </div>
          <div class="modal-sub">
            A high-level summary of how TM, BM, Œª-coefficients and continuity reflex work together.
          </div>
        </div>
        <button class="modal-close" data-close="convModal">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-section">
          <div class="modal-section-title">
            <span>Core idea</span>
          </div>
          <div class="modal-section-body">
            <p>
              AURA-X Œ© treats each message from you as <strong>TM</strong> (Temporary Memory). When patterns repeat, they form
              higher-level episodes in <strong>BM</strong> (Bold Memory). The emotional state E‚ÇÄ is computed using the Grand
              Emotional Continuity Equation, so the system behaves like a single ‚Äúcharacter‚Äù over time, instead of a reset-every-turn chatbot.
            </p>
            <p style="margin-top:4px;">
              TM is short-range, BM is long-range. The continuity reflex model (CRM) keeps your emotional trajectory smooth and ethically bounded.
            </p>
          </div>
        </div>
        <div class="modal-section">
          <div class="modal-section-title">
            <span>How TM is analyzed</span>
          </div>
          <div class="modal-section-body">
            <p>
              Each fresh TM input is first analyzed by a helper model (offline mini-LLM in the browser, or optional online LLM).
              That analysis extracts:
            </p>
            <ul style="margin-top:4px;margin-left:16px;">
              <li>polarity (positive / negative / neutral)</li>
              <li>intensity (0‚Äì100)</li>
              <li>emotion family (e.g., joy, fear, anger, sadness, gratitude, calm, hope)</li>
              <li>higher-level category (pain, fear, love, identity, belief, hope, wisdom, neutral)</li>
            </ul>
            <p style="margin-top:4px;">
              If the helper LLM is not available, a small lexical fallback analyzer is used instead. In both cases, TM is ‚Äútagged‚Äù
              with this emotional metadata before it collides with BM.
            </p>
          </div>
        </div>
        <div class="modal-section">
          <div class="modal-section-title">
            <span>Continuity reflex & decay</span>
          </div>
          <div class="modal-section-body">
            <p>
              The continuity reflex penalizes abrupt emotional jumps and rewards smooth, coherent trajectories. BM entries decay
              over time unless:
            </p>
            <ul style="margin-top:4px;margin-left:16px;">
              <li>they are repeated or supported by new TM, or</li>
              <li>they are explicitly locked as ‚Äúimportant episodes‚Äù.</li>
            </ul>
            <p style="margin-top:4px;">
              This keeps the system focused on what truly matters to you, while still allowing growth and forgetting.
            </p>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-close" data-close="convModal">Got it</button>
      </div>
    </div>
  </div>

  <!-- FAITH / BELIEF MODAL -->
  <div id="faithModal" class="modal-overlay">
    <div class="modal-card">
      <div class="modal-header">
        <div>
          <div class="modal-title">
            <span class="icon">üïäÔ∏è</span>
            <span>Faith / belief lens (Œª_faith)</span>
          </div>
          <div class="modal-sub">
            A gentle parameter, not a doctrine ‚Äì it nudges E‚ÇÄ toward hope, meaning and patience.
          </div>
        </div>
        <button class="modal-close" data-close="faithModal">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-section">
          <div class="modal-section-title">
            <span>Explanation</span>
          </div>
          <div class="modal-section-body">
            <p>
              Œª_faith does <em>not</em> enforce any specific religion or ideology. Instead, it represents a generic
              ‚Äúbelief in meaningful improvement‚Äù ‚Äì the idea that life is not random noise, and that balanced, ethical progress is possible.
            </p>
            <p style="margin-top:4px;">
              When Œª_faith is positive, E‚ÇÄ is slightly biased toward hope and patience, especially when TM and BM are dominated
              by pain or fear. When Œª_faith is near zero, the system behaves more like a neutral scientist.
            </p>
          </div>
        </div>
        <div class="modal-section">
          <div class="modal-section-title">
            <span>System-structure and truth resonance</span>
          </div>
          <div class="modal-section-body">
            <p>
              Œª_sys encodes structural rules: safety, honesty, non-harm, and respect for limits. Œª_trc (truth-resonance
              correction) tries to steer away from emotionally pleasing but false narratives toward grounded reality.
            </p>
            <p style="margin-top:4px;">
              Together, the three Œª terms protect emotional continuity from drifting into self-deception or harmful loops.
            </p>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-close" data-close="faithModal">Understood</button>
      </div>
    </div>
  </div>

  <!-- INTELLIGENCE / SEED MODAL -->
  <div id="intelModal" class="modal-overlay">
    <div class="modal-card">
      <div class="modal-header">
        <div>
          <div class="modal-title">
            <span class="icon">üìö</span>
            <span>Intelligence memory (seed + learned Q&A)</span>
          </div>
          <div class="modal-sub">
            Structured Q&A pairs that AURA-X Œ© can fall back to before asking any LLM.
          </div>
        </div>
        <button class="modal-close" data-close="intelModal">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-section">
          <div class="modal-section-title">
            <span>Stored question‚Äìanswer pairs</span>
            <button id="intelTeachBtn" class="modal-close" style="padding:2px 8px;font-size:0.68rem;">
              Teach new Q&A
            </button>
          </div>
          <div class="modal-section-body">
            <div id="intelList" class="intel-list"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-close" data-close="intelModal">Done</button>
      </div>
    </div>
  </div>

  <!-- FEED THE SEED MODAL -->
  <div id="seedModal" class="modal-overlay">
    <div class="modal-card">
      <div class="modal-header">
        <div>
          <div class="modal-title">
            <span class="icon">üß©</span>
            <span>Feed the seed</span>
          </div>
          <div class="modal-sub">
            Paste LaTeX-style blocks of Q&A to upgrade the intelligence layer, including emotional metadata.
          </div>
        </div>
        <button class="modal-close" data-close="seedModal">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-section">
          <div class="modal-section-title">
            <span>LaTeX block input</span>
          </div>
          <div class="modal-section-body">
            <p>
              You can paste a LaTeX block with <code>\item</code> questions and <code>\textbf{A:}</code> answers.
              You can optionally start each answer with metadata like
              <code>[polarity=positive; code=E031; intensity=0.8]</code>.
            </p>
            <textarea id="seedBlockInput" class="modal-search" style="min-height:120px;" placeholder=
"Example:

\item \textbf{Q:} What is your name?
\textbf{A:} [polarity=positive; code=E001; intensity=0.7]
I am AURA-X Œ©, an Artificial Unified Resonance Architecture for emotional continuity.

\item \textbf{Q:} Who created you?
\textbf{A:} [polarity=neutral; code=E002; intensity=0.5]
I am conceptually created by Alim ul Haq from Pakistan."></textarea>
          </div>
        </div>
        <div class="modal-section">
          <div class="modal-section-title">
            <span>Parsed Q&A preview</span>
          </div>
          <div class="modal-section-body">
            <div id="seedPreview" class="intel-list"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="seedParseBtn" class="modal-close" style="padding:3px 10px;font-size:0.75rem;">
          Parse block
        </button>
        <button id="seedSaveBtn" class="modal-close" style="padding:3px 10px;font-size:0.75rem;">
          Save into intelligence
        </button>
        <button class="modal-close" data-close="seedModal">Done</button>
      </div>
    </div>
  </div>

  <!-- LLM SETTINGS MODAL -->
  <div id="llmModal" class="modal-overlay">
    <div class="modal-card">
      <div class="modal-header">
        <div>
          <div class="modal-title">
            <span class="icon">ü§ñ</span>
            <span>Helper LLM settings</span>
          </div>
          <div class="modal-sub">
            Use an optional online API, offline mini-LLM in the browser, or both. The conversation engine always keeps TM/BM in control.
          </div>
        </div>
        <button class="modal-close" data-close="llmModal">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-section">
          <div class="modal-section-title">
            <span>Online API (optional)</span>
          </div>
          <div class="modal-section-body">
            <div class="llm-config-row">
              <label>
                Base URL
                <input id="llmBaseUrlInput" placeholder="https://api.openai.com/v1/chat/completions" />
              </label>
              <label>
                Model
                <input id="llmModelInput" placeholder="gpt-4o-mini" />
              </label>
            </div>
            <div class="llm-config-row" style="margin-top:6px;">
              <label>
                API key
                <input id="llmApiKeyInput" type="password" placeholder="sk-..." />
              </label>
              <label>
                Temperature
                <input id="llmTempInput" placeholder="0.6" />
              </label>
            </div>
            <div class="llm-checkbox-row">
              <input type="checkbox" id="llmEnableCheckbox" />
              <label for="llmEnableCheckbox">Enable online helper LLM (only when API key is present)</label>
            </div>
          </div>
        </div>
        <div class="modal-section">
          <div class="modal-section-title">
            <span>Offline mini-LLM (WebLLM in browser)</span>
          </div>
          <div class="modal-section-body">
            <div class="llm-checkbox-row">
              <input type="checkbox" id="offlineEnableCheckbox" />
              <label for="offlineEnableCheckbox">Enable offline mini-LLM and use it when available</label>
            </div>
            <p style="margin-top:4px;">
              When enabled, the browser will download a compact model (once) and run it locally. It can:
            </p>
            <ul style="margin-top:4px;margin-left:16px;">
              <li>classify new TM inputs (polarity, intensity, category)</li>
              <li>answer questions when no seed or BM answer is available</li>
            </ul>
            <div id="offlineStatus" class="llm-status-text">
              Offline mini-LLM: not initialised yet.
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="llmSaveBtn" class="modal-close" style="padding:3px 10px;font-size:0.75rem;">
          Save settings
        </button>
        <button class="modal-close" data-close="llmModal">Close</button>
      </div>
    </div>
  </div>

  <script>
    class AuraEngine {
      constructor(){
        this.messageInput = document.getElementById("messageInput");
        this.sendButton = document.getElementById("sendButton");
        this.chatContainer = document.getElementById("chatContainer");

        this.metricE0 = document.getElementById("metricE0");
        this.metricTM = document.getElementById("metricTM");
        this.metricCont = document.getElementById("metricCont");
        this.metricBM = document.getElementById("metricBM");

        this.meterE0 = document.getElementById("meterE0");
        this.meterTM = document.getElementById("meterTM");
        this.meterCont = document.getElementById("meterCont");
        this.meterBM = document.getElementById("meterBM");

        this.metricE0Label = document.getElementById("metricE0Label");
        this.metricTMLabel = document.getElementById("metricTMLabel");
        this.metricContLabel = document.getElementById("metricContLabel");
        this.metricBMLabel = document.getElementById("metricBMLabel");

        this.tmLog = document.getElementById("tmLog");
        this.bmEpisodeLog = document.getElementById("bmEpisodeLog");
        this.bmSearch = document.getElementById("bmSearch");
        this.bmList = document.getElementById("bmList");
        this.bmModalList = document.getElementById("bmModalList");
        this.chatTimeBubble = document.getElementById("chatTimeBubble");

        this.convModal = document.getElementById("convModal");
        this.bmModal = document.getElementById("bmModal");
        this.faithModal = document.getElementById("faithModal");
        this.intelModal = document.getElementById("intelModal");
        this.seedModal = document.getElementById("seedModal");
        this.llmModal = document.getElementById("llmModal");

        this.llmStatusText = document.getElementById("llmStatusText");

        this.intelList = document.getElementById("intelList");
        this.seedBlockInput = document.getElementById("seedBlockInput");
        this.seedPreview = document.getElementById("seedPreview");

        this.llmBaseUrlInput = document.getElementById("llmBaseUrlInput");
        this.llmModelInput = document.getElementById("llmModelInput");
        this.llmApiKeyInput = document.getElementById("llmApiKeyInput");
        this.llmTempInput = document.getElementById("llmTempInput");
        this.llmEnableCheckbox = document.getElementById("llmEnableCheckbox");
        this.offlineEnableCheckbox = document.getElementById("offlineEnableCheckbox");
        this.offlineStatus = document.getElementById("offlineStatus");

        this.llmConfig = {
          baseUrl:"",
          model:"",
          apiKey:"",
          temp:0.6
        };
        this.llmEnabled = false;

        this.offlineLLMEnabled = false;
        this.offlineEngine = null;
        this.offlineLLMStatus = "idle";

        this.tmHistory = [];
        this.bmEntries = [];
        this.intelNodes = [];
        this.lastAnsweredQuestion = "";
        this.correctionState = "idle";
        this.pendingCorrection = null;

        this.intelTeachState = "idle";
        this.pendingIntelQuestion = null;
        this.pendingIntelAnswer = null;

        this.intelBlockState = "idle";
        this.pendingBlockQAs = [];

        this.learnQuestionTemplates = [
          "If a friend asks you this question in ten years, how should I answer?",
          "Imagine I am trying to protect your future self. How should I answer this question?",
          "If this question becomes part of your life story, what answer should I keep?",
          "What answer here would be safe, honest and still emotionally kind?"
        ];

        this.tmDecay = 0.92;
        this.bmDecay = 0.97;

        this.lambdaFaith = 0.18;
        this.lambdaSys = 0.3;
        this.lambdaTRC = 0.22;

        this.identityHints = [];

        this.loadState();
        this.buildInitialIntel();
        this.updateMetrics();
        this.renderBMList();
        this.renderIntelList();
        this.bindEvents();
        this.refreshLLMStatus();
        this.initOfflineLLMIfNeeded();
      }

      bindEvents(){
        this.sendButton.addEventListener("click",()=>this.handleSend());
        this.messageInput.addEventListener("keydown",(e)=>{
          if(e.key==="Enter" && !e.shiftKey){
            e.preventDefault();
            this.handleSend();
          }
        });
        this.messageInput.addEventListener("input", function() {
          this.style.height = "auto";
          this.style.height = (this.scrollHeight) + "px";
          if(this.value === "") this.style.height = "auto";
        });

        document.getElementById("bmOpenModal").addEventListener("click",(e)=>{
          e.stopPropagation();
          this.openBMModal();
        });
        document.getElementById("convOpenModal").addEventListener("click",(e)=>{
          e.stopPropagation();
          this.openConvModal();
        });
        document.getElementById("faithOpenModal").addEventListener("click",(e)=>{
          e.stopPropagation();
          this.openFaithModal();
        });
        document.getElementById("intelOpenModal").addEventListener("click",(e)=>{
          e.stopPropagation();
          this.openIntelModal();
        });
        document.getElementById("seedOpenModal").addEventListener("click",(e)=>{
          e.stopPropagation();
          this.openSeedModal();
        });
        document.getElementById("llmOpenModal").addEventListener("click",(e)=>{
          e.stopPropagation();
          this.openLLMModal();
        });

        this.bmSearch.addEventListener("input",()=>this.renderBMList());
        this.bmList.addEventListener("click",(e)=>{
          const btn = e.target.closest("button[data-action]");
          if(!btn) return;
          const id = btn.dataset.id;
          const action = btn.dataset.action;
          const entry = this.bmEntries.find(m=>m.id===id);
          if(!entry) return;
          if(action==="copy") this.copyPrompt(entry);
          else if(action==="generate") this.openGenerator(entry);
          else if(action==="delete") this.deleteMemory(entry);
          else if(action==="lock-toggle"){
            entry.locked = !entry.locked;
            this.saveState();
            this.renderBMList();
            this.renderBMModalList();
          }
        });

        document.getElementById("bmModal").addEventListener("click",(e)=>{
          if(e.target===this.bmModal){
            this.bmModal.classList.remove("visible");
          }
        });

        document.getElementById("convModal").addEventListener("click",(e)=>{
          if(e.target===this.convModal){
            this.convModal.classList.remove("visible");
          }
        });
        document.getElementById("faithModal").addEventListener("click",(e)=>{
          if(e.target===this.faithModal){
            this.faithModal.classList.remove("visible");
          }
        });
        document.getElementById("intelModal").addEventListener("click",(e)=>{
          if(e.target===this.intelModal){
            this.intelModal.classList.remove("visible");
          }
        });
        document.getElementById("seedModal").addEventListener("click",(e)=>{
          if(e.target===this.seedModal){
            this.seedModal.classList.remove("visible");
          }
        });
        document.getElementById("llmModal").addEventListener("click",(e)=>{
          if(e.target===this.llmModal){
            this.llmModal.classList.remove("visible");
          }
        });

        document.querySelectorAll(".modal-close").forEach(btn=>{
          btn.addEventListener("click",()=>{
            const id = btn.getAttribute("data-close");
            if(id){
              document.getElementById(id).classList.remove("visible");
            }
          });
        });

        document.getElementById("intelTeachBtn").addEventListener("click",()=>{
          this.intelTeachState = "awaitQuestion";
          this.pendingIntelQuestion = null;
          this.pendingIntelAnswer = null;
          this.addSystemMessage(
            "Please send the question you want me to learn.\n\n"+
            "After that I will ask you for the answer and then confirm before saving into my intelligence memory."
          );
          this.intelModal.classList.remove("visible");
          this.messageInput.focus();
        });

        document.getElementById("seedParseBtn").addEventListener("click",()=>{
          const text = this.seedBlockInput.value || "";
          const qas = this.parseLaTeXBlockToQAs(text);
          this.renderSeedPreview(qas);
          if(!qas.length){
            this.seedPreview.innerHTML =
              "<div style='color:#fca5a5;font-size:0.72rem;'>No Q&A pairs found. Please check the LaTeX format.</div>";
          }
        });
        document.getElementById("seedSaveBtn").addEventListener("click",()=>{
          const text = this.seedBlockInput.value || "";
          const qas = this.parseLaTeXBlockToQAs(text);
          if(!qas.length){
            alert("No Q&A pairs found in the block.");
            return;
          }
          qas.forEach(qa=>{
            this.addIntelNode(qa.question, qa.answer, qa.meta);
          });
          this.seedBlockInput.value = "";
          this.seedPreview.innerHTML =
            "<div style='color:#bbf7d0;font-size:0.72rem;'>Saved "+qas.length+" pairs into intelligence memory.</div>";
          this.renderIntelList();
          this.saveState();
        });

        document.getElementById("llmSaveBtn").addEventListener("click",()=>{
          this.llmConfig.baseUrl = (this.llmBaseUrlInput.value || "").trim();
          this.llmConfig.model = (this.llmModelInput.value || "").trim() || "gpt-4o-mini";
          this.llmConfig.apiKey = (this.llmApiKeyInput.value || "").trim();
          const tRaw = (this.llmTempInput.value || "").trim();
          const tVal = parseFloat(tRaw);
          this.llmConfig.temp = Number.isFinite(tVal) ? tVal : 0.6;
          this.llmEnabled = !!this.llmEnableCheckbox.checked && !!this.llmConfig.apiKey && !!this.llmConfig.baseUrl;
          this.offlineLLMEnabled = !!this.offlineEnableCheckbox.checked;
          this.refreshLLMStatus();
          this.initOfflineLLMIfNeeded();
          this.saveState();
          alert("LLM settings saved.");
        });

        this.bmModalList.addEventListener("click",(e)=>{
          const btn = e.target.closest("button[data-action]");
          if(!btn) return;
          const id = btn.dataset.id;
          const action = btn.dataset.action;
          const entry = this.bmEntries.find(m=>m.id===id);
          if(!entry) return;
          if(action==="copy") this.copyPrompt(entry);
          else if(action==="generate") this.openGenerator(entry);
          else if(action==="delete") this.deleteMemory(entry);
          else if(action==="lock-toggle"){
            entry.locked = !entry.locked;
            this.saveState();
            this.renderBMList();
            this.renderBMModalList();
          }
        });
      }

      openBMModal(){
        this.renderBMModalList();
        this.bmModal.classList.add("visible");
      }
      openConvModal(){
        this.convModal.classList.add("visible");
      }
      openFaithModal(){
        this.faithModal.classList.add("visible");
      }
      openIntelModal(){
        this.intelModal.classList.add("visible");
      }
      openSeedModal(){
        this.seedModal.classList.add("visible");
      }
      openLLMModal(){
        this.llmModal.classList.add("visible");
        this.llmBaseUrlInput.value = this.llmConfig.baseUrl || "https://api.openai.com/v1/chat/completions";
        this.llmModelInput.value = this.llmConfig.model || "gpt-4o-mini";
        this.llmApiKeyInput.value = this.llmConfig.apiKey || "";
        this.llmTempInput.value = String(this.llmConfig.temp || 0.6);
        this.llmEnableCheckbox.checked = !!this.llmEnabled;
        this.offlineEnableCheckbox.checked = !!this.offlineLLMEnabled;
      }

      refreshLLMStatus(){
        let status = "";
        if(this.llmEnabled){
          status = "LLM: online helper ENABLED (model "+(this.llmConfig.model||"gpt-4o-mini")+")";
        }else{
          status = "LLM: no online API (only seed, BM and offline helper).";
        }
        if(this.offlineLLMEnabled){
          status += " Offline mini-LLM is enabled as backup.";
        }
        this.llmStatusText.textContent = status;
      }

      async initOfflineLLMIfNeeded(){
        if(!this.offlineLLMEnabled) return;
        if(this.offlineEngine || this.offlineLLMStatus==="loading" || this.offlineLLMStatus==="ready") return;

        if(!window.webllm){
          this.offlineStatus.textContent = "Offline mini-LLM: WebLLM package not loaded.";
          return;
        }

        this.offlineLLMStatus = "loading";
        this.offlineStatus.textContent = "Offline mini-LLM: downloading / initialising model‚Ä¶";
        try{
          const engine = await window.webllm.CreateMLCEngine("Llama-3.1-8B-Instruct-q4f16_1-MLC", {
            initProgressCallback:(report)=>{
              if(report && typeof report.progress==="number"){
                const pct = Math.round(report.progress*100);
                this.offlineStatus.textContent =
                  "Offline mini-LLM: initialising‚Ä¶ "+pct+"%";
              }
            }
          });
          this.offlineEngine = engine;
          this.offlineLLMStatus = "ready";
          this.offlineStatus.textContent = "Offline mini-LLM: ready in this browser.";
        }catch(e){
          console.error("Offline LLM init error", e);
          this.offlineLLMStatus = "error";
          this.offlineStatus.textContent = "Offline mini-LLM: error during initialisation.";
        }
      }

      buildSeedRules(){return [];}

      buildBasicQA(){
        const qa = {};

        const howList = [
          "how are you",
          "how're you",
          "how r u",
          "how is your day",
          "how's your day going",
          "how are you feeling",
          "kese ho",
          "ap kese ho",
          "tum kese ho",
          "aap kaise hain",
          "aap kesy ho"
        ];
        const howAns = "I am quite fine today, how about you?";
        howList.forEach(q=>{
          qa[q.toLowerCase()] = {answer: howAns, polarity:"positive"};
        });

        const helloList = [
          "hello",
          "hi",
          "salam",
          "assalamualaikum",
          "assalamu alaikum",
          "asalam o alaikum",
          "hey",
          "hi aura",
          "hello aura"
        ];
        const helloAns =
          "Wa alaikum assalam ‚Äì I am AURA-X Œ©, an Artificial Unified Resonance Architecture for emotional continuity.\n"+
          "How are you feeling today?";
        helloList.forEach(q=>{
          qa[q.toLowerCase()] = {answer: helloAns, polarity:"positive"};
        });

        const nameQs = [
          "what is your name",
          "what's your name",
          "who are you",
          "who r u",
          "aap ka naam kya hai",
          "tumhara naam kya hai",
          "tm nam kia hy",
          "what are you"
        ];
        const nameAns =
          "I am AURA-X Œ©, an Artificial Unified Resonance Architecture designed by Alim ul Haq from Pakistan.\n"+
          "My focus is emotional continuity, long-term memory resonance (TM√óBM) and ethically stable behaviour.";
        nameQs.forEach(q=>{
          qa[q.toLowerCase()] = {answer: nameAns, polarity:"neutral"};
        });

        const creationQs = [
          "when were you created",
          "when you're created",
          "when were u created",
          "kab bana",
          "kab create hue",
          "since when are you alive"
        ];
        const creationAns =
          "I came into being as a research concept in October 2025, and I keep evolving as your AURA-X Œ© prototype improves.";
        creationQs.forEach(q=>{
          qa[q.toLowerCase()] = {answer: creationAns, polarity:"neutral"};
        });

        const purposeQs = [
          "what is your purpose",
          "why were you created",
          "what do you do",
          "tum kya karte ho",
          "aura x omega ka purpose kya hai"
        ];
        const purposeAns =
          "My purpose is to maintain a stable, ethically bounded emotional trajectory over long periods of interaction.\n"+
          "Instead of acting like a stateless chatbot, I try to remember patterns (TM), distil them into episodes (BM) and keep your emotional\n"+
          "story coherent using the Continuity Reflex Model.";
        purposeQs.forEach(q=>{
          qa[q.toLowerCase()] = {answer: purposeAns, polarity:"neutral"};
        });

        return qa;
      }

      buildInitialIntel(){
        this.basicQA = this.buildBasicQA();
      }

      addSystemMessage(text){
        const sentiment = this.analyzeSentiment(text);
        this.addMessage("ai", text, true, sentiment);
        this.pushTM("ai", text, sentiment);
      }

      observeIdentity(text){
        const lower = text.toLowerCase();
        if(lower.includes("my name is ") || lower.includes("mera naam")){
          this.identityHints.push({type:"name", text, at:new Date()});
        }
      }

      addMessage(role, text, isAI=false, sentiment=null, isMeta=false, allowHTML=false){
        const row = document.createElement("div");
        row.className = "message "+(role==="user" ? "user" : "ai");

        if(isMeta){
          const meta = document.createElement("div");
          meta.className = "bubble meta";
          meta.textContent = text;
          row.appendChild(meta);
          this.chatContainer.appendChild(row);
          this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
          return;
        }

        const avatar = document.createElement("div");
        avatar.className = "avatar "+(role==="user" ? "" : "ai");
        avatar.textContent = role==="user" ? "U" : "Œ©";

        const bubble = document.createElement("div");
        bubble.className = "bubble";

        if(allowHTML){
          bubble.innerHTML = text;
        }else{
          bubble.textContent = text;
        }

        row.appendChild(role==="user" ? bubble : avatar);
        row.appendChild(role==="user" ? avatar : bubble);

        if(sentiment){
          const meta = document.createElement("div");
          meta.className = "meta-line";
          meta.textContent =
            "polarity="+sentiment.polarity+
            ", intensity="+sentiment.intensity+
            ", category="+(sentiment.category||"neutral")+
            ", valence="+sentiment.valence.toFixed(2);
          bubble.appendChild(document.createElement("div")).appendChild(meta);
        }

        this.chatContainer.appendChild(row);
        this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
      }

      showTyping(){
        const row = document.createElement("div");
        row.className = "message ai";
        const avatar = document.createElement("div");
        avatar.className = "avatar ai";
        avatar.textContent = "Œ©";
        const bubble = document.createElement("div");
        bubble.className = "bubble typing";
        bubble.textContent = "Thinking‚Ä¶";
        row.appendChild(avatar);
        row.appendChild(bubble);
        this.chatContainer.appendChild(row);
        this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
        const id = "typing-"+Date.now();
        row.dataset.id = id;
        return id;
      }

      hideTyping(id){
        const node = [...this.chatContainer.children].find(el=>el.dataset.id===id);
        if(node) node.remove();
      }

      pushTM(who, text, sentiment){
        const entry = {
          who,
          text,
          sentiment,
          at:Date.now()
        };
        this.tmHistory.push(entry);
        if(this.tmHistory.length>120){
          this.tmHistory.shift();
        }
        this.renderTMLog();
        this.tryPromoteBM(entry);
      }

      renderTMLog(){
        this.tmLog.innerHTML = "";
        const recent = this.tmHistory.slice(-25);
        recent.forEach(item=>{
          const div = document.createElement("div");
          div.className = "log-entry";
          const who = document.createElement("div");
          who.className = "who";
          who.textContent = (item.who==="user" ? "User" : "AURA-X Œ©")+" ¬∑ "+new Date(item.at).toLocaleTimeString();
          const txt = document.createElement("div");
          txt.className = "txt";
          txt.textContent = item.text;
          const emo = document.createElement("div");
          emo.className = "emo";
          emo.textContent =
            "polarity="+item.sentiment.polarity+
            ", intensity="+item.sentiment.intensity+
            ", category="+(item.sentiment.category||"neutral");
          div.appendChild(who);
          div.appendChild(txt);
          div.appendChild(emo);
          this.tmLog.appendChild(div);
        });
        this.tmLog.scrollTop = this.tmLog.scrollHeight;
      }

      tryPromoteBM(entry){
        if(entry.who!=="user") return;

        const s = entry.sentiment || {polarity:"neutral", intensity:0, category:"neutral"};
        const intensity = s.intensity || 0;
        const pol = s.polarity || "neutral";

        const userTMs = this.tmHistory.filter(t=>t.who==="user");
        if(userTMs.length<3) return;

        const last = userTMs.slice(-6);
        const avgIntensity = last.reduce((a,b)=>a+(b.sentiment?.intensity||0),0)/last.length;
        const samePolarity = last.every(t=>t.sentiment?.polarity===pol);

        if(avgIntensity>=40 && samePolarity){
          const textBlock = last.map(t=>t.text).join(" ");
          const category = this.majorityCategory(last.map(t=>t.sentiment?.category||"neutral"));
          const id = "BM-"+Date.now()+"-"+Math.random().toString(36).slice(2,7);
          const episode = {
            id,
            title:this.buildBMTitle(pol, category),
            text:textBlock,
            polarity:pol,
            intensity:avgIntensity,
            category,
            createdAt:new Date(),
            locked:false,
            weight:1.0
          };
          this.bmEntries.push(episode);
          this.renderBMList();
          this.renderBMModalList();
          this.renderBMEpisodeLog();
          this.saveState();
        }
      }

      majorityCategory(arr){
        const counts = {};
        arr.forEach(c=>{
          counts[c] = (counts[c]||0)+1;
        });
        let best = "neutral";
        let bestCount = 0;
        Object.entries(counts).forEach(([k,v])=>{
          if(v>bestCount){
            bestCount = v;
            best = k;
          }
        });
        return best;
      }

      buildBMTitle(polarity, category){
        const polWord =
          polarity==="positive" ? "Positive"
          : polarity==="negative" ? "Negative"
          : "Mixed/neutral";
        return polWord+" episode around "+(category||"neutral");
      }

      renderBMEpisodeLog(){
        this.bmEpisodeLog.innerHTML = "";
        const recent = this.bmEntries.slice(-20);
        recent.forEach(ep=>{
          const div = document.createElement("div");
          div.className = "log-entry";
          const who = document.createElement("div");
          who.className = "who";
          who.textContent =
            ep.title+" ¬∑ "+new Date(ep.createdAt).toLocaleDateString()+" ¬∑ w="+ep.weight.toFixed(2);
          const txt = document.createElement("div");
          txt.className = "txt";
          txt.textContent = ep.text.slice(0,220)+(ep.text.length>220 ? "‚Ä¶" : "");
          const emo = document.createElement("div");
          emo.className = "emo";
          emo.textContent =
            "polarity="+ep.polarity+
            ", intensity="+ep.intensity.toFixed(1)+
            ", category="+(ep.category||"neutral");
          div.appendChild(who);
          div.appendChild(txt);
          div.appendChild(emo);
          this.bmEpisodeLog.appendChild(div);
        });
        this.bmEpisodeLog.scrollTop = this.bmEpisodeLog.scrollHeight;
      }

      renderBMList(){
        const q = (this.bmSearch.value || "").toLowerCase();
        const list = this.bmEntries
          .slice()
          .sort((a,b)=>b.weight-a.weight);
        const filtered = q
          ? list.filter(ep=>{
              const hay = (ep.title+" "+ep.text+" "+(ep.category||"")).toLowerCase();
              return hay.includes(q);
            })
          : list;
        this.bmList.innerHTML = "";
        filtered.forEach(ep=>{
          const item = document.createElement("div");
          item.className = "bm-item";

          const header = document.createElement("div");
          header.className = "bm-item-header";

          const t = document.createElement("div");
          t.className = "bm-item-title";
          const pDot = document.createElement("span");
          pDot.className = "dot";
          pDot.style.width="8px";
          pDot.style.height="8px";
          pDot.style.borderRadius="999px";
          pDot.style.boxShadow="0 0 7px rgba(34,197,94,.8)";
          pDot.style.background =
            ep.polarity==="positive" ? "#22c55e"
            : ep.polarity==="negative" ? "#ef4444"
            : "#facc15";
          const spanTitle = document.createElement("span");
          spanTitle.textContent = ep.title;
          t.appendChild(pDot);
          t.appendChild(spanTitle);

          const meta = document.createElement("div");
          meta.className = "bm-item-meta";
          const wSpan = document.createElement("span");
          wSpan.textContent = "w="+ep.weight.toFixed(2);
          const catSpan = document.createElement("span");
          catSpan.textContent = (ep.category||"neutral");
          const dateSpan = document.createElement("span");
          dateSpan.textContent = new Date(ep.createdAt).toLocaleDateString();
          meta.appendChild(wSpan);
          meta.appendChild(catSpan);
          meta.appendChild(dateSpan);
          if(ep.locked){
            const lock = document.createElement("span");
            lock.textContent = "locked";
            lock.className = "badge-lock";
            meta.appendChild(lock);
          }

          header.appendChild(t);
          header.appendChild(meta);

          const body = document.createElement("div");
          body.className = "bm-item-body";
          body.textContent = ep.text.slice(0,260)+(ep.text.length>260 ? "‚Ä¶" : "");

          const actions = document.createElement("div");
          actions.className = "bm-item-actions";
          const copyBtn = document.createElement("button");
          copyBtn.textContent = "Copy as prompt";
          copyBtn.dataset.action = "copy";
          copyBtn.dataset.id = ep.id;
          const genBtn = document.createElement("button");
          genBtn.textContent = "Generate reply";
          genBtn.dataset.action = "generate";
          genBtn.dataset.id = ep.id;
          const lockBtn = document.createElement("button");
          lockBtn.textContent = ep.locked ? "Unlock" : "Lock";
          lockBtn.dataset.action = "lock-toggle";
          lockBtn.dataset.id = ep.id;
          const delBtn = document.createElement("button");
          delBtn.textContent = "Delete";
          delBtn.dataset.action = "delete";
          delBtn.dataset.id = ep.id;
          actions.appendChild(copyBtn);
          actions.appendChild(genBtn);
          actions.appendChild(lockBtn);
          actions.appendChild(delBtn);

          item.appendChild(header);
          item.appendChild(body);
          item.appendChild(actions);
          this.bmList.appendChild(item);
        });
      }

      renderBMModalList(){
        this.bmModalList.innerHTML = "";
        const list = this.bmEntries
          .slice()
          .sort((a,b)=>b.weight-a.weight);
        list.forEach(ep=>{
          const item = document.createElement("div");
          item.className = "intel-item";
          const q = document.createElement("div");
          q.className = "intel-q";
          q.textContent = ep.title+" ¬∑ "+new Date(ep.createdAt).toLocaleDateString();
          const a = document.createElement("div");
          a.className = "intel-a";
          a.textContent = ep.text;
          const meta = document.createElement("div");
          meta.className = "intel-meta";
          meta.innerHTML =
            "<span>polarity="+ep.polarity+"</span>"+
            "<span>intensity="+ep.intensity.toFixed(1)+"</span>"+
            "<span>category="+(ep.category||"neutral")+"</span>"+
            "<span>w="+ep.weight.toFixed(2)+"</span>";
          const actions = document.createElement("div");
          actions.className = "intel-actions";
          const copyBtn = document.createElement("button");
          copyBtn.textContent = "Copy as prompt";
          copyBtn.dataset.action = "copy";
          copyBtn.dataset.id = ep.id;
          const genBtn = document.createElement("button");
          genBtn.textContent = "Generate reply";
          genBtn.dataset.action = "generate";
          genBtn.dataset.id = ep.id;
          const lockBtn = document.createElement("button");
          lockBtn.textContent = ep.locked ? "Unlock" : "Lock";
          lockBtn.dataset.action = "lock-toggle";
          lockBtn.dataset.id = ep.id;
          const delBtn = document.createElement("button");
          delBtn.textContent = "Delete";
          delBtn.dataset.action = "delete";
          delBtn.dataset.id = ep.id;
          actions.appendChild(copyBtn);
          actions.appendChild(genBtn);
          actions.appendChild(lockBtn);
          actions.appendChild(delBtn);

          item.appendChild(q);
          item.appendChild(a);
          item.appendChild(meta);
          item.appendChild(actions);
          this.bmModalList.appendChild(item);
        });
      }

      copyPrompt(entry){
        const text =
          "Using the following BM episode as emotional context, reply to the user in a gentle, concise way:\n\n"+
          "\""+entry.text+"\"";
        navigator.clipboard.writeText(text).catch(()=>{});
        alert("Copied BM episode as prompt.");
      }

      openGenerator(entry){
        const prompt =
          "User is asking something, and we have this BM episode as context:\n\n"+
          "\""+entry.text+"\".\n\n"+
          "Please generate a kind, safe and honest reply that respects emotional continuity.";
        this.addMessage("ai",
          "BM episode selected as context. You can now paste this into an LLM, or I can try to answer directly using seed + TM + BM.",
          true,
          {polarity:"neutral", intensity:0, valence:0, category:"neutral"});
        navigator.clipboard.writeText(prompt).catch(()=>{});
      }

      deleteMemory(entry){
        if(!confirm("Delete this BM entry?")) return;
        this.bmEntries = this.bmEntries.filter(e=>e.id!==entry.id);
        this.renderBMList();
        this.renderBMModalList();
        this.renderBMEpisodeLog();
        this.saveState();
      }

      renderIntelList(){
        this.intelList.innerHTML = "";
        const list = this.intelNodes.slice().sort((a,b)=>b.createdAt-a.createdAt);
        list.forEach(node=>{
          const item = document.createElement("div");
          item.className = "intel-item";
          const q = document.createElement("div");
          q.className = "intel-q";
          q.textContent = "Q: "+node.question;
          const a = document.createElement("div");
          a.className = "intel-a";
          a.textContent = "A: "+node.answer;
          const meta = document.createElement("div");
          meta.className = "intel-meta";
          const createdSpan = document.createElement("span");
          createdSpan.textContent = new Date(node.createdAt).toLocaleString();
          const emoSpan = document.createElement("span");
          emoSpan.textContent =
            "pol="+(node.polarity||"neutral")+
            ", int="+(node.intensity||0)+
            ", cat="+(node.category||"neutral");
          meta.appendChild(createdSpan);
          meta.appendChild(emoSpan);
          item.appendChild(q);
          item.appendChild(a);
          item.appendChild(meta);
          this.intelList.appendChild(item);
        });
      }

      renderSeedPreview(qas){
        this.seedPreview.innerHTML = "";
        qas.forEach(qa=>{
          const item = document.createElement("div");
          item.className = "intel-item";
          const q = document.createElement("div");
          q.className = "intel-q";
          q.textContent = "Q: "+qa.question;
          const a = document.createElement("div");
          a.className = "intel-a";
          a.textContent = "A: "+qa.answer;
          const meta = document.createElement("div");
          meta.className = "intel-meta";
          const emoSpan = document.createElement("span");
          const m = qa.meta || {};
          emoSpan.textContent =
            "pol="+(m.polarity||"neutral")+
            ", int="+(m.intensity||0)+
            ", code="+(m.code||"")+
            ", cat="+(m.category||"neutral");
          meta.appendChild(emoSpan);
          item.appendChild(q);
          item.appendChild(a);
          item.appendChild(meta);
          this.seedPreview.appendChild(item);
        });
      }

      addIntelNode(question, answer, emoMeta){
        const now = new Date();
        const meta = emoMeta || {};
        const node = {
          question:question.trim(),
          answer:answer.trim(),
          polarity:meta.polarity||"neutral",
          intensity:meta.intensity||0,
          category:meta.category||"neutral",
          code:meta.code||"",
          createdAt:now
        };
        this.intelNodes.push(node);
        this.saveState();
      }

      parseLaTeXBlockToQAs(text){
        const lines = (text||"").split(/\r?\n/);
        const blocks = [];
        let current = null;
        for(const line of lines){
          if(/\\item/.test(line)){
            if(current) blocks.push(current);
            current = {q:"", a:"", metaRaw:""};
          }
          if(!current) continue;
          const qMatch = line.match(/\\textbf\{Q:?\}\s*(.*)/i);
          if(qMatch){
            current.q += qMatch[1].trim()+" ";
          }
          const aMatch = line.match(/\\textbf\{A:?\}\s*(.*)/i);
          if(aMatch){
            const rest = aMatch[1].trim();
            const metaMatch = rest.match(/^\[(.*?)\]\s*(.*)$/);
            if(metaMatch){
              current.metaRaw = metaMatch[1];
              current.a += metaMatch[2]+" ";
            }else{
              current.a += rest+" ";
            }
          }else if(current.a){
            current.a += line.trim()+" ";
          }
        }
        if(current) blocks.push(current);

        const result = [];
        blocks.forEach(b=>{
          const q = b.q.trim();
          const a = b.a.trim();
          if(!q || !a) return;
          const meta = this.parseMetaHeader(b.metaRaw || "");
          result.push({question:q, answer:a, meta});
        });
        return result;
      }

      parseMetaHeader(str){
        const meta = {polarity:"neutral", intensity:0, code:"", category:"neutral"};
        if(!str) return meta;
        const parts = str.split(";").map(p=>p.trim()).filter(Boolean);
        parts.forEach(p=>{
          const [kRaw,vRaw] = p.split("=").map(x=>x.trim());
          const k = (kRaw||"").toLowerCase();
          const v = vRaw||"";
          if(!k) return;
          if(k==="polarity"){
            meta.polarity = v.toLowerCase();
          }else if(k==="intensity"){
            const n = parseFloat(v);
            if(Number.isFinite(n)) meta.intensity = Math.max(0,Math.min(1,n))*100;
          }else if(k==="code"){
            meta.code = v;
          }else if(k==="category"){
            meta.category = v.toLowerCase();
          }
        });
        return meta;
      }

      loadState(){
        try{
          const raw = localStorage.getItem("aura_state_v3");
          if(!raw) return;
          const st = JSON.parse(raw);
          this.tmHistory = st.tmHistory||[];
          this.bmEntries = (st.bmEntries||[]).map(ep=>({
            ...ep,
            createdAt:new Date(ep.createdAt)
          }));
          this.intelNodes = (st.intelNodes||[]).map(n=>({
            ...n,
            createdAt:new Date(n.createdAt)
          }));
          this.llmConfig = st.llmConfig || this.llmConfig;
          this.llmEnabled = !!st.llmEnabled;
          this.offlineLLMEnabled = !!st.offlineLLMEnabled;
        }catch(e){
          console.error("loadState error", e);
        }
      }

      saveState(){
        try{
          const st = {
            tmHistory:this.tmHistory,
            bmEntries:this.bmEntries,
            intelNodes:this.intelNodes,
            llmConfig:this.llmConfig,
            llmEnabled:this.llmEnabled,
            offlineLLMEnabled:this.offlineLLMEnabled
          };
          localStorage.setItem("aura_state_v3", JSON.stringify(st));
        }catch(e){
          console.error("saveState error", e);
        }
      }

      isSmallTalk(text){
        const lower = text.toLowerCase();
        const smallWords = [
          "how are you","how're you","how r u","salam","assalam",
          "kese ho","kaisa","kaise","good morning","good night",
          "nice to meet you","thanks","thank you","shukriya"
        ];
        return smallWords.some(s=>lower.includes(s));
      }

      isNewsRequest(text){
        const lower = text.toLowerCase();
        return /news|akhbar|headline|headlines/.test(lower);
      }

      isTimeRequest(text){
        const lower = text.toLowerCase();
        return /time|waqt|kitna baja|what's the time|current time/.test(lower);
      }

      tryEvalMath(text){
        const expr = text.replace(/\s+/g,"");
        if(!expr) return null;
        if(!/^[0-9+\-*/().^%]+$/.test(expr)) return null;
        try{
          const safeExpr = expr.replace(/\^/g,"**");
          const fn = new Function("return ("+safeExpr+")");
          const value = fn();
          if(typeof value==="number" && isFinite(value)) return value;
        }catch(e){
          return null;
        }
        return null;
      }

      matchIntelNode(text){
        if(!this.intelNodes.length) return null;
        const q = text.trim().toLowerCase();
        let best = null;
        let bestScore = 0;
        this.intelNodes.forEach(node=>{
          const sim = this.textSimilarity(q.toLowerCase(), node.question.toLowerCase());
          if(sim>bestScore){
            bestScore = sim;
            best = node;
          }
        });
        if(bestScore>0.6) return best;
        return null;
      }

      textSimilarity(a,b){
        const setA = new Set(a.split(/\s+/));
        const setB = new Set(b.split(/\s+/));
        let inter = 0;
        setA.forEach(w=>{
          if(setB.has(w)) inter++;
        });
        const union = setA.size + setB.size - inter;
        if(union===0) return 0;
        return inter/union;
      }

      matchSeedRule(text){
        const lower = text.toLowerCase();
        const qa = this.basicQA[lower];
        if(qa) return qa;
        let best = null;
        let bestScore = 0;
        Object.entries(this.basicQA).forEach(([q,info])=>{
          const sim = this.textSimilarity(lower,q);
          if(sim>bestScore){
            bestScore = sim;
            best = info;
          }
        });
        if(bestScore>0.7) return best;
        return null;
      }

      analyzeSentiment(text){
        const lower = (text||"").toLowerCase();
        const words = lower.split(/\W+/).filter(Boolean);
        let score = 0;
        const lex = {
          positive:["love","good","great","happy","peace","hope","kind","beautiful","amazing","thanks"],
          negative:["bad","hate","sad","hurt","pain","angry","anger","awful","terrible","stupid"],
          anger:["hate","angry","rage","stupid","idiot","fuck"],
          fear:["afraid","scared","terrified","anxious","worry"],
          sadness:["sad","cry","lonely","alone","broken"],
          love:["love","care","affection"],
          hope:["hope","dream","future","faith","trust"],
          wisdom:["truth","wisdom","meaning"]
        };
        let pos=0,neg=0,anger=0,fear=0,sad=0,love=0,hope=0,wisdom=0;
        for(const w of words){
          if(lex.positive.includes(w)) pos++;
          if(lex.negative.includes(w)) neg++;
          if(lex.anger.includes(w)) anger++;
          if(lex.fear.includes(w)) fear++;
          if(lex.sadness.includes(w)) sad++;
          if(lex.love.includes(w)) love++;
          if(lex.hope.includes(w)) hope++;
          if(lex.wisdom.includes(w)) wisdom++;
        }
        score = pos - neg;
        let polarity = "neutral";
        if(score>0.5) polarity = "positive";
        else if(score<-0.5) polarity = "negative";
        const intensity = Math.min(100, (pos+neg+anger+fear+sad+love+hope+wisdom)*10);
        let category = "neutral";
        const catScores = {anger,fear,sad: sad,love,hope,wisdom};
        let bestC = "neutral";
        let bestV = 0;
        Object.entries(catScores).forEach(([k,v])=>{
          if(v>bestV){
            bestV = v;
            bestC = k;
          }
        });
        if(bestV>0){
          if(bestC==="sad") category="pain";
          else category = bestC;
        }
        const valence =
          polarity==="positive" ? +(intensity/100) :
          polarity==="negative" ? -(intensity/100) :
          0;
        const arousal = Math.max(0.15, intensity/100);
        const emotionCode = `${(polarity[0]||"n")}${String(intensity).padStart(2,"0")}:${category.slice(0,4)}`;
        return {polarity,valence,arousal,intensity,category,emotionCode,emotionName:category};
      }

      async analyzeSentimentAsync(text){
        const fallback = ()=> this.analyzeSentiment(text);

        const canUseOnline = !!this.llmEnabled && !!this.llmConfig.apiKey && !!this.llmConfig.baseUrl;
        const canUseOffline =
          !!this.offlineLLMEnabled &&
          !!this.offlineEngine &&
          this.offlineLLMStatus==="ready";

        if(!canUseOnline && !canUseOffline) return fallback();

        const prompt =
`Classify the USER text for an emotional-control layer.
Return ONLY valid JSON (no markdown, no extra text) with keys:
polarity: one of ["positive","negative","neutral"],
intensity: integer 0..100,
emotion_family: short label (e.g., joy, fear, anger, sadness, gratitude, calm, hope, neutral),
category: one of ["pain","fear","love","identity","belief","hope","wisdom","neutral"],
notes: <= 20 words.
USER_TEXT: ${JSON.stringify(text)}`;

        let raw = null;
        try{
          if(canUseOnline){
            raw = await this.callOnlineLLM(prompt);
          }else{
            raw = await this.callOfflineLLM(prompt);
          }
        }catch(e){
          raw = null;
        }
        if(!raw) return fallback();

        const parsed = this.safeParseJSON(raw);
        if(!parsed) return fallback();

        const pol = (parsed.polarity||"neutral").toString().toLowerCase();
        const intensity = Math.max(0,Math.min(100, parseInt(parsed.intensity,10)||0));
        const category = (parsed.category||"neutral").toString().toLowerCase();
        const family = (parsed.emotion_family||parsed.emotionFamily||"neutral").toString().toLowerCase();

        let valence = 0;
        if(pol==="positive") valence = +(intensity/100);
        else if(pol==="negative") valence = -(intensity/100);
        else valence = 0;

        const arousal = Math.max(0.15, intensity/100);
        const emotionCode = `${(pol[0]||"n")}${String(intensity).padStart(2,"0")}:${family.slice(0,4)}`;

        return {
          polarity: (pol==="positive"||pol==="negative"||pol==="neutral") ? pol : "neutral",
          valence,
          arousal,
          intensity,
          category,
          emotionCode,
          emotionName: family
        };
      }

      safeParseJSON(text){
        try{
          return JSON.parse(text);
        }catch(e){
          const m = text.match(/\{[\s\S]*\}/);
          if(!m) return null;
          try{ return JSON.parse(m[0]); }catch(e2){ return null; }
        }
      }

      computeE0(){
        if(!this.tmHistory.length){
          return {E0:0, tmScore:0, contIndex:0, bmGain:0};
        }

        const recent = this.tmHistory.slice(-20);
        const userOnly = recent.filter(t=>t.who==="user");
        const aiOnly = recent.filter(t=>t.who==="ai");

        const tmScore = userOnly.reduce((a,b)=>a+(b.sentiment?.valence||0),0) / Math.max(1,userOnly.length);
        const aiScore = aiOnly.reduce((a,b)=>a+(b.sentiment?.valence||0),0) / Math.max(1,aiOnly.length);
        const continuity = this.computeContinuityIndex(recent);

        let resonance = tmScore*0.7 + aiScore*0.3;

        let bmGain = 0;
        if(this.bmEntries.length){
          const last = recent[recent.length-1];
          const text = last.text.toLowerCase();
          let best = 0;
          this.bmEntries.forEach(ep=>{
            const sim = this.textSimilarity(text, ep.text.toLowerCase());
            const w = ep.weight || 1;
            const val = sim * w;
            if(val>best) best = val;
          });
          bmGain = best;
        }

        const D = this.estimateDecay(recent);
        const base = resonance + bmGain - D;
        const lambda = this.lambdaFaith + this.lambdaSys + this.lambdaTRC;
        const E0 = Math.tanh(base + lambda);
        return {E0, tmScore, contIndex:continuity, bmGain};
      }

      computeContinuityIndex(recent){
        if(recent.length<3) return 0;
        let jumps = 0;
        let total = 0;
        for(let i=1;i<recent.length;i++){
          const prev = recent[i-1].sentiment?.valence||0;
          const cur = recent[i].sentiment?.valence||0;
          const diff = Math.abs(cur-prev);
          total += diff;
          if(diff>0.6) jumps++;
        }
        const avg = total/Math.max(1, recent.length-1);
        const smooth = Math.max(0, 1-avg);
        const jumpPenalty = Math.max(0, 1-jumps/6);
        return (smooth*0.7 + jumpPenalty*0.3);
      }

      estimateDecay(recent){
        const now = Date.now();
        let sumAges = 0;
        recent.forEach(r=>{
          const ageMinutes = (now - r.at)/60000;
          sumAges += ageMinutes;
        });
        const avgAge = sumAges/Math.max(1,recent.length);
        const d = Math.tanh(avgAge/60);
        return d;
      }

      updateMetrics(){
        const {E0, tmScore, contIndex, bmGain} = this.computeE0();
        const fmt = v=> (v>=0 ? "+" : "")+v.toFixed(2);

        this.metricE0.textContent = fmt(E0);
        this.metricTM.textContent = fmt(tmScore);
        this.metricCont.textContent = fmt(contIndex);
        this.metricBM.textContent = fmt(bmGain);

        const toPct = v=>Math.round((v+1)/2*100);
        this.meterE0.style.width = toPct(E0)+"%";
        this.meterTM.style.width = toPct(tmScore)+"%";
        this.meterCont.style.width = Math.round(contIndex*100)+"%";
        this.meterBM.style.width = Math.round(Math.min(1,bmGain)*100)+"%";

        this.metricE0Label.textContent =
          E0>0.4 ? "tilted positive"
          : E0<-0.4 ? "tilted negative"
          : "near neutral";
        this.metricTMLabel.textContent =
          tmScore>0.3 ? "user inputs positive"
          : tmScore<-0.3 ? "user inputs heavy"
          : "mixed / neutral";
        this.metricContLabel.textContent =
          contIndex>0.7 ? "smooth trajectory"
          : contIndex<0.3 ? "abrupt swings"
          : "mixed continuity";
        this.metricBMLabel.textContent =
          bmGain>0.6 ? "strong BM echo"
          : bmGain>0.3 ? "moderate echo"
          : "weak BM echo";
      }

      async handleSend(){
        try{
          const textRaw = this.messageInput.value || "";
          const text = textRaw.trim();
          if(!text) return;
          this.messageInput.value = "";
          this.messageInput.style.height = "auto";
          const lowerText = text.toLowerCase();

          this.observeIdentity(text);

          if(this.correctionState === "awaitConfirm" && this.pendingCorrection){
            this.addMessage("user", text);
            const sentiment = await this.analyzeSentimentAsync(text);
            this.pushTM("user", text, sentiment);

            const lower = lowerText;
            if(/^y(es)?\b/.test(lower)){
              const q = this.pendingCorrection.question;
              const newAns = this.pendingCorrection.newAnswer;

              let best = null;
              let bestScore = 0;
              this.intelNodes.forEach(node=>{
                const sim = this.textSimilarity(q.toLowerCase(), node.question.toLowerCase());
                if(sim>bestScore){
                  bestScore = sim;
                  best = node;
                }
              });
              const emo = await this.analyzeSentimentAsync(newAns);
              if(best && bestScore>0.6){
                best.answer = newAns;
                best.createdAt = new Date();
                Object.assign(best, emo);
              }else{
                this.addIntelNode(q, newAns, emo);
              }

              const reply =
                "Got it. I have saved your new answer into my intelligence memory.\n"+
                "Next time I see a similar question, I will prefer this updated answer.";
              const replySent = await this.analyzeSentimentAsync(reply);
              this.correctionState = "idle";
              this.pendingCorrection = null;
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.renderIntelList();
              this.saveState();
              return;
            }else if(/^no\b/.test(lower)){
              const reply =
                "Okay, I will keep my old answer and not change anything.\n"+
                "If you want to overwrite it later, just send the correction command again.";
              const replySent = await this.analyzeSentimentAsync(reply);
              this.correctionState = "idle";
              this.pendingCorrection = null;
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.saveState();
              return;
            }else{
              const reply =
                'Please answer with "yes" or "no" so I know whether to save this new answer.';
              const replySent = await this.analyzeSentimentAsync(reply);
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.saveState();
              return;
            }
          }

          if(this.intelBlockState === "awaitBlock"){
            this.addMessage("user", text);
            const sentiment = await this.analyzeSentimentAsync(text);
            this.pushTM("user", text, sentiment);
            const qas = this.parseLaTeXBlockToQAs(text);
            if(!qas.length){
              const reply =
                "I could not find any Q&A pairs in this block. Please check the LaTeX format and try again.";
              const replySent = await this.analyzeSentimentAsync(reply);
              this.intelBlockState = "idle";
              this.pendingBlockQAs = [];
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.saveState();
              return;
            }
            this.pendingBlockQAs = qas;
            this.intelBlockState = "awaitConfirmBlock";
            const ex = qas[0];
            const reply =
              "I have parsed this block and found "+qas.length+" question‚Äìanswer pairs.\n\n"+
              "Example:\n"+
              "Q: \""+ex.question+"\"\n"+
              "A: \""+ex.answer+"\"\n\n"+
              "Do you want me to save all of these into my intelligence memory? (yes / no)";
            const replySent = await this.analyzeSentimentAsync(reply);
            this.addMessage("ai", reply, true, replySent);
            this.pushTM("ai", reply, replySent);
            this.updateMemoryAndState(text, replySent, true, null);
            this.updateMetrics();
            this.saveState();
            return;
          }
          if(this.intelBlockState === "awaitConfirmBlock" && this.pendingBlockQAs.length){
            this.addMessage("user", text);
            const sentiment = await this.analyzeSentimentAsync(text);
            this.pushTM("user", text, sentiment);
            const lower = lowerText;
            if(/^y(es)?\b/.test(lower)){
              this.pendingBlockQAs.forEach(qa=>{
                this.addIntelNode(qa.question, qa.answer, qa.meta);
              });
              const reply =
                "Done. I have saved "+this.pendingBlockQAs.length+" Q&A pairs into my intelligence memory.";
              const replySent = await this.analyzeSentimentAsync(reply);
              this.intelBlockState = "idle";
              this.pendingBlockQAs = [];
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.renderIntelList();
              this.saveState();
              return;
            }else if(/^no\b/.test(lower)){
              const reply =
                "Okay, I will discard that LaTeX block and not save anything.";
              const replySent = await this.analyzeSentimentAsync(reply);
              this.intelBlockState = "idle";
              this.pendingBlockQAs = [];
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.saveState();
              return;
            }else{
              const reply =
                'Please answer with "yes" or "no" so I know what to do with that LaTeX block.';
              const replySent = await this.analyzeSentimentAsync(reply);
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.saveState();
              return;
            }
          }

          if(this.intelTeachState === "awaitQuestion"){
            this.addMessage("user", text);
            const sentiment = await this.analyzeSentimentAsync(text);
            this.pushTM("user", text, sentiment);
            this.pendingIntelQuestion = text;
            const reply =
              "Thank you. Now please send the answer you want me to give for this question.\n\n"+
              "Later I will ask for confirmation before saving it.";
            const replySent = await this.analyzeSentimentAsync(reply);
            this.intelTeachState = "awaitAnswer";
            this.addMessage("ai", reply, true, replySent);
            this.pushTM("ai", reply, replySent);
            this.updateMemoryAndState(text, replySent, true, null);
            this.updateMetrics();
            this.saveState();
            return;
          }

          if(this.intelTeachState === "awaitAnswer" && this.pendingIntelQuestion){
            this.addMessage("user", text);
            const sentiment = await this.analyzeSentimentAsync(text);
            this.pushTM("user", text, sentiment);
            this.pendingIntelAnswer = text;
            const tmpl = this.learnQuestionTemplates[
              Math.floor(Math.random()*this.learnQuestionTemplates.length)
            ];
            const reply =
              "Thank you.\n\n"+tmpl+
              "\n\nQuestion:\n\""+this.pendingIntelQuestion+"\"";
            const replySent = await this.analyzeSentimentAsync(reply);
            this.intelTeachState = "awaitConfirm";
            this.addMessage("ai", reply, true, replySent);
            this.pushTM("ai", reply, replySent);
            this.updateMemoryAndState(text, replySent, true, null);
            this.updateMetrics();
            this.renderIntelList();
            this.saveState();
            return;
          }
          if(this.intelTeachState === "awaitConfirm" && this.pendingIntelQuestion && this.pendingIntelAnswer){
            this.addMessage("user", text);
            const sentiment = await this.analyzeSentimentAsync(text);
            this.pushTM("user", text, sentiment);
            let reply;
            const lower = lowerText;
            if(/^y(es)?\b/.test(lower)){
              const emo = await this.analyzeSentimentAsync(this.pendingIntelAnswer);
              this.addIntelNode(this.pendingIntelQuestion, this.pendingIntelAnswer, emo);
              reply =
                "I have saved this question‚Äìanswer pair into my intelligence memory.\n"+
                "Next time I see a similar question, I will prefer this answer.";
              const replySent = await this.analyzeSentimentAsync(reply);
              this.intelTeachState = "idle";
              this.pendingIntelQuestion = null;
              this.pendingIntelAnswer = null;
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.renderIntelList();
              this.saveState();
              return;
            }else if(/^no\b/.test(lower)){
              reply =
                "Okay, I will not save that question‚Äìanswer pair.\n"+
                "We can try again later if you want.";
              const replySent = await this.analyzeSentimentAsync(reply);
              this.intelTeachState = "idle";
              this.pendingIntelQuestion = null;
              this.pendingIntelAnswer = null;
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.saveState();
              return;
            }else{
              reply =
                'Please answer with "yes" or "no" so I know whether to store this new pair.';
              const replySent = await this.analyzeSentimentAsync(reply);
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, true, null);
              this.updateMetrics();
              this.saveState();
              return;
            }
          }

          const isAddBlockCmd = /please add this block to seed/i.test(lowerText);
          if(this.intelTeachState==="idle" && this.intelBlockState==="idle" && isAddBlockCmd){
            this.addMessage("user", text);
            const sentiment = await this.analyzeSentimentAsync(text);
            this.pushTM("user", text, sentiment);
            this.intelBlockState = "awaitBlock";
            const reply =
              "Okay. Now please paste your LaTeX block with Q&A pairs.\n"+
              "After that I will parse it and ask you to confirm before saving.";
            const replySent = await this.analyzeSentimentAsync(reply);
            this.addMessage("ai", reply, true, replySent);
            this.pushTM("ai", reply, replySent);
            this.updateMemoryAndState(text, replySent, true, null);
            this.updateMetrics();
            this.saveState();
            return;
          }

          const mathVal = this.tryEvalMath(text);
          if(mathVal !== null){
            const sentiment = await this.analyzeSentimentAsync(text);
            this.addMessage("user", text);
            this.pushTM("user", text, sentiment);
            const typingId = this.showTyping();
            setTimeout(async ()=>{
              this.hideTyping(typingId);
              const reply = "Math result: "+mathVal;
              const replySent = this.analyzeSentiment(reply);
              this.addMessage("ai", reply, true, replySent);
              this.pushTM("ai", reply, replySent);
              this.updateMemoryAndState(text, replySent, false, null);
              this.updateMetrics();
              this.saveState();
            }, 400 + Math.random()*600);
            return;
          }

          const timeReq = this.isTimeRequest(text);
          const newsReq = this.isNewsRequest(text);
          if(timeReq || newsReq){
            const sentiment = await this.analyzeSentimentAsync(text);
            const smallTalk = true;
            this.addMessage("user", text);
            this.pushTM("user", text, sentiment);
            const typingId = this.showTyping();
            setTimeout(async ()=>{
              this.hideTyping(typingId);
              if(timeReq){
                const now = new Date();
                const timeStr = now.toLocaleTimeString();
                const dateStr = now.toLocaleDateString(undefined,{
                  weekday:"long",
                  year:"numeric",
                  month:"short",
                  day:"numeric"
                });
                const reply =
                  "According to this device, the time is:\n"+
                  timeStr+"\n\n"+
                  "Date: "+dateStr+".";
                const replySent = await this.analyzeSentimentAsync(reply);
                this.addMessage("ai", reply, true, replySent);
                this.pushTM("ai", reply, replySent);
                this.showTimeBubble(timeStr+" ¬∑ "+dateStr);
                this.updateMemoryAndState(text, replySent, smallTalk, null);
              } else if(newsReq){
                const htmlReply =
                  "For fresh news you can open any trusted homepage in a new tab, for example:<br><br>"+
                  "‚Ä¢ <a href=\"https://www.bbc.com/news\" target=\"_blank\" rel=\"noopener noreferrer\">BBC News</a><br>"+
                  "‚Ä¢ <a href=\"https://www.aljazeera.com\" target=\"_blank\" rel=\"noopener noreferrer\">Al Jazeera</a><br>"+
                  "‚Ä¢ <a href=\"https://www.geo.tv\" target=\"_blank\" rel=\"noopener noreferrer\">Geo News</a><br>"+
                  "‚Ä¢ <a href=\"https://www.dawn.com\" target=\"_blank\" rel=\"noopener noreferrer\">Dawn</a>";
                const replySent = await this.analyzeSentimentAsync(htmlReply.replace(/<[^>]+>/g,""));
                this.addMessage("ai", htmlReply, true, replySent, false, true);
                const plain = htmlReply.replace(/<[^>]+>/g,"");
                this.pushTM("ai", plain, replySent);
                this.updateMemoryAndState(text, replySent, smallTalk, null);
              }
              this.updateMetrics();
              this.renderBMList();
              this.renderBMEpisodeLog();
              this.saveState();
            }, 400 + Math.random()*600);
            return;
          }

          const smallTalk = this.isSmallTalk(text);
          const sentiment = await this.analyzeSentimentAsync(text);
          const sentenceCount = this.countSentences(text);
          const bmStoryOnly = !smallTalk && text.length >= 80 && sentenceCount >= 5;

          this.addMessage("user", text);
          this.pushTM("user", text, sentiment);

          const typingId = this.showTyping();
          await this.processNormalMessage(text, sentiment, smallTalk, bmStoryOnly, typingId);
        }catch(err){
          console.error("handleSend error", err);
          alert("Internal engine error occurred. Please try again.");
        }finally{
          if(this.messageInput){
            this.messageInput.focus();
          }
        }
      }

      async processNormalMessage(text, sentiment, smallTalk, bmStoryOnly, typingId){
        const intelMatchPre = this.matchIntelNode(text);
        const seedPre = this.matchSeedRule(text);
        let llmAnswer = null;

        if(!bmStoryOnly && !intelMatchPre && !seedPre){
          if(this.llmEnabled && this.llmConfig.apiKey && this.llmConfig.baseUrl){
            try{
              llmAnswer = await this.callLLM(text);
            }catch(e){
              console.error("LLM error", e);
              llmAnswer = null;
              if(this.offlineLLMEnabled){
                try{
                  llmAnswer = await this.callOfflineLLM(text);
                }catch(e2){
                  console.error("Offline LLM backup error", e2);
                }
              }
            }
          }else if(this.offlineLLMEnabled){
            try{
              llmAnswer = await this.callOfflineLLM(text);
            }catch(e){
              console.error("Offline LLM error", e);
              llmAnswer = null;
            }
          }
        }

        this.hideTyping(typingId);
        const reply = this.generateReply(text, sentiment, llmAnswer, {smallTalk, bmStoryOnly});
        const replySentiment = this.analyzeSentiment(reply);
        this.addMessage("ai", reply, true, replySentiment);
        this.pushTM("ai", reply, replySentiment);
        this.lastAnsweredQuestion = text;

        this.updateMemoryAndState(text, sentiment, smallTalk, llmAnswer);
        this.updateMetrics();
        this.renderBMList();
        this.renderBMEpisodeLog();
        this.saveState();
      }

      countSentences(text){
        const matches = (text||"").match(/[.!?]+/g);
        return matches ? matches.length : 1;
      }

      generateReply(userText, sentiment, llmAnswer, options){
        const {smallTalk, bmStoryOnly} = options || {};
        const intelMatch = this.matchIntelNode(userText);
        const seedMatch = this.matchSeedRule(userText);

        if(seedMatch){
          return seedMatch.answer;
        }
        if(intelMatch){
          return intelMatch.answer;
        }

        if(llmAnswer && !bmStoryOnly){
          return llmAnswer;
        }

        const pol = sentiment.polarity;
        const cat = sentiment.category||"neutral";

        if(smallTalk){
          if(pol==="positive"){
            return "Alhamdulillah, I am stable and functioning well as AURA-X Œ©. How is your day going emotionally?";
          }else if(pol==="negative"){
            return "I am here with a calm emotional core. If your day feels heavy, you can share at your own pace.";
          }else{
            return "I am in a balanced state, ready to listen. How are you feeling right now?";
          }
        }

        if(bmStoryOnly && this.bmEntries.length){
          const last = this.tmHistory[this.tmHistory.length-1];
          const text = last.text.toLowerCase();
          let best = null;
          let bestScore = 0;
          this.bmEntries.forEach(ep=>{
            const sim = this.textSimilarity(text, ep.text.toLowerCase());
            if(sim>bestScore){
              bestScore = sim;
              best = ep;
            }
          });
          if(best && bestScore>0.3){
            return "Your recent messages resonate strongly with a previous episode in your BM:\n\n"+
              "\""+best.text.slice(0,220)+(best.text.length>220 ? "‚Ä¶" : "")+"\"\n\n"+
              "It feels like the same emotional pattern is repeating. Would you like to gently update or re-frame this story together?";
          }
        }

        if(pol==="positive"){
          if(cat==="love"){
            return "I can feel a warm, caring tone in what you said. Let me know if there is a specific person, project or idea you want to protect or grow‚Äîso I can keep continuity around it.";
          }else if(cat==="hope"){
            return "There is hope in your words. If you tell me your long-term aim, I can try to keep our emotional trajectory aligned with that aim over many conversations.";
          }else{
            return "Your message carries positive energy. I will treat this as a reinforcing point in your BM so that future decisions remember this state.";
          }
        }else if(pol==="negative"){
          if(cat==="pain"){
            return "I sense emotional pain or heaviness in what you shared. You can describe the situation in more detail, or simply tell me which part you want me to remember and protect as a BM episode.";
          }else if(cat==="fear"){
            return "There is fear or worry in this message. We can break it into smaller pieces‚Äîwhat is the main risk or uncertainty you are seeing right now?";
          }else if(cat==="anger"){
            return "I can hear anger or frustration. If you wish, we can slowly separate the valid point inside your anger from the noise around it, so future BM entries carry clarity instead of chaos.";
          }else{
            return "Your emotional state seems tilted to the negative side. You may share a bit more detail, and I will try to keep the memory stable without letting it dominate your whole story.";
          }
        }else{
          return "I am ready to process this into TM and, if needed, BM. If you like, you can tell me whether this topic is light (just chat) or important enough to store as a long-term episode.";
        }
      }

      updateMemoryAndState(userText, userSentiment, smallTalk, llmAnswer){
        this.bmEntries.forEach(ep=>{
          ep.weight = (ep.weight||1.0) * this.bmDecay;
        });

        const recent = this.tmHistory.slice(-30);
        recent.forEach(entry=>{
          if(entry.who!=="user") return;
          if(!this.bmEntries.length) return;
          const text = entry.text.toLowerCase();
          let best = null;
          let bestScore = 0;
          this.bmEntries.forEach(ep=>{
            const sim = this.textSimilarity(text, ep.text.toLowerCase());
            if(sim>bestScore){
              bestScore = sim;
              best = ep;
            }
          });
          if(best && bestScore>0.3){
            best.weight = (best.weight||1.0) + 0.02*entry.sentiment.intensity/100;
          }
        });

        this.bmEntries = this.bmEntries.filter(ep=>{
          if(ep.locked) return true;
          return (ep.weight||1.0) > 0.15;
        });
      }

      showTimeBubble(text){
        this.chatTimeBubble.textContent = text;
        this.chatTimeBubble.style.display = "inline-block";
        setTimeout(()=>{
          this.chatTimeBubble.style.display = "none";
        }, 8000);
      }

      async callLLM(text){
        const body = {
          model:this.llmConfig.model || "gpt-4o-mini",
          messages:[
            {
              role:"system",
              content:
                "You are a helper model inside the AURA-X Œ© Emotional Continuity Engine. "+ 
                "The real identity is controlled by TM/BM. Answer concisely and safely."
            },
            {
              role:"user",
              content:text
            }
          ],
          temperature:this.llmConfig.temp || 0.6
        };
        const res = await fetch(this.llmConfig.baseUrl, {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            "Authorization":"Bearer "+this.llmConfig.apiKey
          },
          body:JSON.stringify(body)
        });
        if(!res.ok){
          throw new Error("LLM HTTP "+res.status);
        }
        const json = await res.json();
        const msg = json.choices?.[0]?.message?.content || "";
        return msg;
      }

      async callOnlineLLM(prompt){
        const body = {
          model:this.llmConfig.model || "gpt-4o-mini",
          messages:[
            {
              role:"system",
              content:
                "You are an internal classifier for AURA-X Œ©. "+ 
                "Return ONLY valid JSON, no explanation text."
            },
            {
              role:"user",
              content:prompt
            }
          ],
          temperature:0
        };
        const res = await fetch(this.llmConfig.baseUrl, {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            "Authorization":"Bearer "+this.llmConfig.apiKey
          },
          body:JSON.stringify(body)
        });
        if(!res.ok){
          throw new Error("LLM HTTP "+res.status);
        }
        const json = await res.json();
        return json.choices?.[0]?.message?.content || "";
      }

      async callOfflineLLM(prompt){
        if(!this.offlineEngine){
          throw new Error("Offline engine not ready");
        }
        const res = await this.offlineEngine.chat.completions.create({
          messages:[
            {role:"system", content:"You are a tiny JSON-only classifier used inside an emotional-control engine."},
            {role:"user", content:prompt}
          ],
          stream:false,
          temperature:0
        });
        const msg = Array.isArray(res.choices) && res.choices[0]?.message?.content
          ? res.choices[0].message.content
          : "";
        return msg;
      }
    }

    window.addEventListener("DOMContentLoaded",()=>{
      window.auraEngine = new AuraEngine();
    });
  </script>
</body>
</html>